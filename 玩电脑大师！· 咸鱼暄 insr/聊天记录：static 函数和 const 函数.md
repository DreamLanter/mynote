记录一下引发过思考的聊天记录）有空了再整理到笔记里

为什么静态函数不能被定义为只读函数<br />是不是说，函数是不是只读的这个概念只在非静态函数里才存在（因为其定义是是否改变对象的数据域）<br />以及，我们知道不改变对象的数据域的函数可以定义为只读函数。那么，是不是这些函数必须被定义为只读函数？（否则compiler会报错）


我觉得const和static函数是并列关系，表明它们对实例的使用：普通函数允许读取和修改this指针指向实例的值；const允许读取但不允许修改；static都不允许，所以干脆没有this这回事了

我觉得const和static不应当是必须的（当然程序员最好显式地说明），你说的“报错”我觉得可能是因为你在const函数里调用了非const函数，或者用const对象调用了非const函数才会报错；因为显然在我们刚才的 “普通<const<static”的关系中，static里调用this的const函数和普通函数是非法的（实际上他为了防止这个，直接拒绝了对this的任何访问）；在const里调用this的普通函数也是非法的

const和static最显然的冲突是，const是隐式地包含了一个只读的this指针的，而static是不允许有this指针的，这两个规则发生了冲突，所以不可以同时用在一个函数里

首先一个概念是<br />static和const<br />只有在类的成员函数里才有<br />对于一个成员函数（我们先不讨论static函数），这个函数被调用的时候必然是由具体的某个对象调用的<br />这时候编译器实际上是会传给这个函数一个参数，是Class*类型的一个指针（Class是这个类名），告诉他是谁调用的他<br />由于必然有且仅有一个对象调用了这个函数，所以这个指针一定是确定且非空的

![image.png](./assets/1616852839296-4857eec3-3441-43ee-8c1a-df4fb41bb1d8.png)
比如这样一个类<br />第7行<br />return this->age;<br />你可能会写成return age;<br />这是因为在没有命名歧义的时候，我们可以省略this<br />编译器自动帮你找到age

但是如果你想一想你就会发现，<br />如果函数不知道this<br />他根本不可能找到这个age<br />所以函数一定是知道谁调用他的 渠道就是这个this指针

![image.png](./assets/1616852833022-91bcfeec-5fec-41e6-96e2-679f567d7b88.png)
我喜欢这样写构造函数<br />这时候this的作用就很明显<br />看7-8行<br />name既是一个成员变量，也是一个传入参数<br />那么由于变量的屏蔽效应，在这里写name默认指的是传入的参数<br />如果想要找到那个成员变量 就需要显式地使用this->name<br />（好像只有这种情况下this无法避免）<br />总结来说this就是个形参 是调用的时候传给他的 比如这个类叫 A，那普通函数传进去的时候它的类型就是 A* const（后面这个 const 表示 this 的值不能改），const函数传进去的时候就是 const A* const（前面那个 const 表示它指的是一个 const A，也就是说这个对象的内容也不能改），static 函数直接就不传了

