---

本文是 [咸鱼暄的 C++ 学习](https://www.yuque.com/xianyuxuan/coding/cpp) 的补充部分 [2 C++知识补充](https://www.yuque.com/xianyuxuan/coding/cpppp) 的一个章节。

---

对于较小的变量，应当尽可能传值而非传引用。因为引用在每次使用时仍需要解引用，可能会带来额外的开销。

---


### 2.6.1 基本语法
在C语言中，符号 **&** 是 **取地址符** 。而在 C++ 中，& 有一个新的作用：定义引用变量。引用就是某一个变量的别名， **对引用的操作和对变量直接操作完全一样** 。定义语法为： **Type &refVarName = varName; **。<br />引用与指针类似，但需要注意的有：

   - 不存在空引用。引用必须连接到一块合法的内存，因此 **声明引用时，必须同时进行初始化** 。
   - 引用变量声明完毕后， 相当于原变量有了2个名称，即引用名和原名。 **引用不占存储单元，对引用和原变量取址的结果是一样的** 。
   - 一旦引用被初始化为一个对象，就不能被指向到另一个对象。即 **不能将一个引用名重新作为其他变量名的别名** 。
   - 不能建立数组的引用。

指针解决了我们在传递参数时复制带来的效率和空间消耗等问题。而引用相比于指针更加安全（避免对内存的非法引用）、可读性更高，同时不需要额外分配内存单元。

和指针类似，`int &a = b, c = d`中，`a`的类型是`int &`，而`c`的类型是`int`。<br />引用其实就是指针包装了一下。


### 2.6.2 引用的应用
通过引用取一个别名是没有意义的。引用的目的主要用于函数的参数传递。其应用有下：

#### 将引用作为传入参数
例如：
```cpp
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}
int main(){
    int var1 = 1, var2 = 2;
    swap(var1, var2);
    cout<<var1<<" "<<var2<<endl;
    return 0;
}
```
输出是： `2 1` 。


#### 将引用作为返回值
当函数返回一个引用，函数值可以作为赋值表达式的左值：
```cpp
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
double& setValues(int i){
  return vals[i];   // 返回第 i 个元素的引用
}
int main (){
   setValues(0) = 20.23; // 改变第 0 个元素
}
```
当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。例如：
```cpp
int& fun() {
   int q;
   // return q;  // 编译错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```
除了上面第一段代码的应用外，将引用作为返回值允许了链式调用（参见本节 **引用与一些操作符的重载**）。<br />同时，当引用作为类的成员函数的返回值时，允许我们在类外访问类内的私有变量。例如：
```cpp
class SaltyFish{
    int x = 0;
public:
    int &fun(){
        return x;
    }
    int getX(){
        return x;
    }
};
int main(){
    SaltyFish saltyFish;
    saltyFish.fun() = 2;
    cout<<saltyFish.getX();
}
```
输出为 `2` 。<br />当然，如果不希望这样的事情发生，可以将fun()函数的返回值类型定义为 `const int &` 。


#### 引用与多态 仅复制，待处理 
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例如：
```cpp
class  A;
class  B：public A{……};
B  b;
A  &Ref = b; // 用派生类对象初始化基类对象的引用
```
Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。


#### 引用与一些操作符的重载 仅复制，待处理 
流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一 个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。<br />赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。


### 2.6.3 常引用
常引用使用 **const** **Type &refVarName = varName; **定义。这样的定义使得我们不能通过 refVarName （引用名）修改目标变量的值（即只读），但用原名仍可修改。这可以使得引用更加安全。<br />另外，常引用也支持这样的形式： `const int& q = 12;` 。<br />同时，常引用也能满足某些其他方面的需要。例如在下面代码段中：
```cpp
string f();
void fun(string &str);
int main(){
    //ERROR: fun("123");
    //ERROR: fun(f());
}
```
4、5行会导致编译错误。这是因为，f() 和 "123" 都会产生一个临时的对象，其类型为 **const string** 。因此这里我们试图将一个 const 类型的对象转化为一个非 const 类型的，这是非法的（但是将非 const 类型转化为 const 类型是合法的）。我们应该将函数 fun 的传入参数类型改为 `const string &str` 。<br />**引用型参数应该在能定义成 const 的情况下，尽可能定义为 const** 。

---


### 参考资料

1. [OI Wiki](https://oi-wiki.org/)
2. [C++ 教程 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)
3. 引用的语法和应用 - [https://www.cnblogs.com/mlgjb/p/8821340.html](https://www.cnblogs.com/mlgjb/p/8821340.html)
