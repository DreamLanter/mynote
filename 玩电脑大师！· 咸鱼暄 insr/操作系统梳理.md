{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"}},"body":[{"id":"08d5341b-5f60-4837-af88-fa5f5128b722","x":72.199951171875,"y":260.79998779296875,"html":"操作系统","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"rgb(245, 245, 245)"},"zIndex":254,"children":[{"treeEdge":{"stroke":"#A287E1"},"id":"ceba6ab5-1687-4259-bc11-e5d7217c061f","children":[{"border":{"shape":"capsule"},"id":"6c4e0b0d-b5f1-4c74-9d5b-b9c8976db5f8","children":[{"html":"我们现在搞好了一个 CPU，还有配套的内存之类的设备，现在要用它。可以直接把汇编写到内存里运行。","border":{"shape":"line"},"id":"240b7246-8517-4ed5-abc6-73cce3a896d7","children":[],"zIndex":9},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"8ee867bd-f6b3-45a7-b886-6a24db0a5377","children":[],"zIndex":8,"height":254.1999969482422,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666280163614-66b77da1-a66a-4037-9cc6-5db60f6c2f3b.png","naturalWidth":1441,"naturalHeight":816,"uploadInfo":{"hash":"2074445e8d5f21e9253a482b51464f61a6492c0b4809817718823d1e6ec94664","fileName":"image.png","fileType":"image/png","fileSize":97233,"localTempSrc":"blob:https://www.yuque.com/094440f2-fc34-41c4-99ea-7a86b1fa0403","state":-2},"firstInsertRatio":0.4,"width":384.4000244140625,"height":217.67551694786607},"width":400.4000244140625},{"html":"计算机最开始是为了研究可计算性理论的，但很快就被用于一些专用的计算，例如破译密码等；随后演化出了 general-purpose, multifunction mainframes","border":{"shape":"line"},"id":"9eabed16-2e1d-44ca-a530-4ab94ae3e42a","children":[],"zIndex":7},{"border":{"shape":"line"},"id":"49addeac-014e-4006-bb1e-b219b1dc67bc","children":[{"border":{"shape":"line"},"id":"bd462ce7-2d93-45e1-a6ca-078e3eaffafc","children":[],"html":"<span style=\"font-weight:bold;\">批处理系统, Batch Processing Systems</span>。Jobs 在内存或者外存里，内存始终有一个 job 在运行，操作系统负责在结束后加载下一个开始运行（我们将加载到内存并运行的程序为 <span style=\"font-weight:bold;\">进程, process</span>）。问题在于如果运行时发生 I/O，CPU 就会停下来等 I/O 完成。","layout":{"quadrant":1},"zIndex":2},{"html":"<span style=\"font-weight:bold;\">多道批处理系统, Multiprogramming Batch Systems</span>。在批处理系统基础上，当当前 job 发生 I/O 时，操作系统负责让 CPU 转而运行另一个 job。问题在于，没有考虑和用户的交互，响应时间较长。","border":{"shape":"line"},"id":"84b531c8-ed89-4e00-9c74-84d42f533a4e","children":[],"layout":{"quadrant":1},"zIndex":1},{"html":"<span style=\"font-weight:bold;\">分时系统, Time Sharing Systems</span>。将 CPU 时间划分为很小的时间片，操作系统负责安排各个 job 轮流运行。由于切换频率很高，从而用户通过输入设备向计算机发出指令时可以收到实时的回复。<div>分时系统本身也是一种多道 (multiprogramming) 系统，即允许多个 job 并发 (concurrently) 执行。但是不是批处理 (batch) 系统。</div>","border":{"shape":"line"},"layout":{"quadrant":1},"id":"fb928626-c629-45be-bddf-3e4895af9eca","children":[],"zIndex":0}],"zIndex":6,"html":"如果有很多程序要一个一个运行，怎么办呢？写一个一直运行的程序 (<span style=\"font-weight:bold;\">kernel</span>)，负责其他程序的运行。","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"除了 kernel 外，操作系统还包含一些 <span style=\"font-weight:bold;\">system programs</span>，辅助 kernel 工作。其他程序不属于操作系统，称为 <span style=\"font-weight:bold;\">application programs</span>。","border":{"shape":"line"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"id":"6f08f479-44c9-46ad-a955-6384a2214c37","children":[],"zIndex":5},{"html":"总结来说，操作系统是“软件中最基础的部分”，用以控制和管理系统资源、方便用户使用计算机。","border":{"shape":"line"},"id":"833cdda2-1859-437e-82ce-a22546229ec4","children":[],"zIndex":4},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"42a2f6cc-5585-4877-a40c-6a082d6ba623","children":[],"zIndex":3,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666330636998-ddf604ed-be86-48f2-9d95-b5f134020a1e.png","naturalWidth":1411,"naturalHeight":827,"uploadInfo":{"hash":"016c889a3a863b397886540e9bba108dedaca55af03c6e9cc91624718753e579","fileName":"image.png","fileType":"image/png","fileSize":73067,"localTempSrc":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666330636998-ddf604ed-be86-48f2-9d95-b5f134020a1e.png","state":-2},"firstInsertRatio":0.4,"width":480,"height":281.33238837703755}}],"zIndex":32,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"操作系统是啥","collapsed":true},{"border":{"shape":"capsule"},"id":"d267e4bc-0e50-451b-9ec3-2c2db0a1432b","children":[{"border":{"shape":"line"},"id":"5fa8e351-d4fb-48ce-b990-7b88eb6cf918","children":[],"zIndex":17,"html":"批处理系统的实现是容易理解的；每个程序就像是一个函数一样被操作系统调用。那么其他类型的操作系统是如何实现在程序运行时能够收回控制权呢？这就需要使用到 <span style=\"font-weight:bold;\">中断 (interrupt)</span>。现代操作系统都是 <span style=\"font-weight:bold;\">中断驱动 (interrupt driven) </span>的。"},{"html":"事件发生通常通过硬件或软件的中断通知。CPU 硬件有一条称为 interrupt-request line 的线路，CPU 在执行每一条指令后都要检测它一次。当 CPU 侦测到一个设备控制器在这条线路上发出的信号时，会读取 interrupt number 并且以此作为 interrupt vector 中的 index 来跳转到对应的 interrupt-handler routine。","border":{"shape":"line"},"id":"81ec43fd-b217-4c38-b92c-ada3b3252e4f","children":[{"html":"中断向量表 (interrupt vector) 用来减少确定中断服务时的查找次数，即通过随机访问而不是遍历的方式找到处理程序。","border":{"shape":"line"},"layout":{"quadrant":1},"id":"0f63b6fa-b0ae-4a55-a4f5-21ae08759159","children":[],"zIndex":13},{"border":{"shape":"line"},"id":"4ea35666-53cc-4d92-95c6-2ee1edba5cf1","children":[],"zIndex":12,"html":"在现在的操作系统上，我们还需要一些更复杂的中断处理功能：<div>1. 我们需要能够在关键程序处理期间延迟中断的处理；</div><div>2. 我们需要一种高效的方法来将设备中断发给正确的中断处理程序；</div><div>3. 我们需要多级中断，从而使得操作系统可以区分不同优先级的中断并根据适当的紧急程度进行响应。</div>"},{"html":"在现代的计算机硬件中，这些特性由 CPU 和 interrupt-controller hardware 实现。<div>大多数 CPU 有两条 interrupt-request line，一条用于 nonmaskable interrupt，为一些不可恢复的内存错误等事件保留；另一条是 maskable 的，它可以在执行不可中断的关键程序之前被 CPU 关闭，用于传送一些设备控制器的中断请求。</div>","border":{"shape":"line"},"id":"94391c95-4e2e-4a0c-95b0-1ba42949572d","children":[],"zIndex":11},{"html":"我们都知道，在调用函数时需要保存 PC 等现场状态；执行中断时也需要保存。但是，值得注意的是，虽然低级的中断可以被高级的中断打断，但是保存和恢复现场状态的过程是不能被打断的。","border":{"shape":"line"},"id":"2bbf7f1a-cd28-40d8-9c27-453d96cecf50","children":[],"zIndex":10}],"zIndex":16,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"9234257a-f600-42c3-8eb2-55c0b2e52ecb","children":[],"zIndex":15,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666326340185-634434e6-90b9-4e87-a1a8-dc343d35a32b.png","naturalWidth":1906,"naturalHeight":955,"uploadInfo":{"hash":"97a5faa8b6ddc66d93861b8612584357d40c49b07acad0c2a2aa28593713b143","fileName":"image.png","fileType":"image/png","fileSize":254550,"localTempSrc":"blob:https://www.yuque.com/1f87e260-59b6-4885-838e-92526bdf9c3a","state":-2},"firstInsertRatio":0.4,"width":480,"height":240.5036726128017}},{"html":"当操作系统将 CPU 的控制权交给一个程序前，会设定好一个 <span style=\"font-weight:bold;\">计时器 (timer)</span>。计时器通过一个时钟和一个计数器实现。当计数器的值为 0 时，就会产生一个中断，这时控制权就交给了操作系统。这种方式可以防止程序执行时间过长，也可以用来实现分时系统。","border":{"shape":"line"},"id":"ee6dd540-59e1-40f0-b408-5c7b723a9d22","children":[],"zIndex":14}],"zIndex":31,"html":"中断 | Interrupt","collapsed":true},{"border":{"shape":"capsule"},"id":"2d7c9cd4-7054-4431-8065-59664f73c1ab","children":[{"border":{"shape":"line"},"id":"14a79354-20b7-4198-8a8c-8a9910888c15","children":[],"zIndex":24,"html":"操作系统和用户共享计算机的软件和硬件。因此，一个错误的程序可能会导致整个系统崩溃，或者使得其他用户的数据甚至操作系统本身被修改。因此，操作系统的设计要保证一个错误的程序不会造成其他程序的错误运行。"},{"html":"我们将操作系统代码和用户代码区分执行。出于安全考虑，用户代码不能直接执行部分可能引起损害的指令；我们称这些指令为 <span style=\"font-weight:bold;\">privileged instructions</span>。CPU 硬件有一个 <span style=\"font-weight:bold;\">mode bit</span>，值为 0 表示当前处于 <span style=\"font-weight:700;\">kernel mode (或称为 supervisor mode, system mode, privileged mode)</span>；值为 1 表示当前处于 <span style=\"font-weight:bold;\">user mode</span>，此时 CPU 将会把所有 privileged inst. 视为非法指令。","border":{"shape":"line"},"id":"4d6082f2-1411-4009-a60c-99fca995e9c6","children":[],"zIndex":23},{"html":"所有的 interrupt handler 都运行在 kernel mode","border":{"shape":"line"},"id":"766cb735-f284-438a-b8e0-ee87f3c94498","children":[],"zIndex":22},{"html":"那如果用户程序确实想做这些事情怎么办呢？它们可以通过 <span style=\"font-weight:bold;\">system call</span> 的方式向操作系统提出请求，由操作系统代为完成。","border":{"shape":"line"},"id":"3114d4fe-0ea1-4567-8e0d-c7eea3084ad7","children":[],"zIndex":21},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"05c6a726-3afc-4a2e-8057-2d38b9497cd8","children":[],"zIndex":20,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666330220879-767403e2-c6fc-4f03-80e3-1cec797ddee2.png","naturalWidth":1855,"naturalHeight":703,"uploadInfo":{"hash":"782f984d89e039f5811168a2bb2fbc114782d6b6ac6c9cf762d4450977df6e49","fileName":"image.png","fileType":"image/png","fileSize":108821,"localTempSrc":"blob:https://www.yuque.com/c3c28755-b873-4c19-bd4a-e4b5d86f7c2b","state":-2},"firstInsertRatio":0.4,"width":480,"height":181.90835579514822}},{"html":"也有可能有更多 mode，或者叫 <span style=\"font-weight:bold;\">privilege level</span>。例如在虚拟化的情境下，可能会支持多于 user mode 但是少于 kernel mode 的指令等。","border":{"shape":"line"},"id":"3b78a12f-24c1-4922-bdf7-707da7a2a0a1","children":[],"zIndex":19},{"html":"因此，当发生中断、system call、错误（例如除以 0，或者访问未知指令）等情况时，会发生 user mode 到 kernel mode 的转换。","border":{"shape":"line"},"id":"42af70a7-bd0e-447f-87ed-a9ca1aca3b4b","children":[],"zIndex":18}],"zIndex":30,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"Dual-mode &amp; Multimode","collapsed":true},{"border":{"shape":"capsule"},"id":"3cec887e-c63d-48db-97c8-60e877d7155c","children":[{"border":{"shape":"line"},"id":"af9a09e8-e9e1-4414-aabe-6ec8e3afdc0b","children":[],"zIndex":28,"html":"系统调用可能需要<span style=\"font-weight:bold;\">传递参数</span>。参数可以放在寄存器里直接传递；也可以放在一块内存中，用寄存器传递地址；也可以用栈传递。"},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"9bbd8768-e9e8-45fb-b434-a129a3c52e96","children":[],"zIndex":27,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666331005609-f525b620-4f5d-4e48-afe7-c21ef08d8c4c.png","naturalWidth":707,"naturalHeight":836,"uploadInfo":{"hash":"1cd38bdf839691a07337ecfe716d55be90545de73e2efb4715bc40ece6320fab","fileName":"image.png","fileType":"image/png","fileSize":104722,"localTempSrc":"blob:https://www.yuque.com/a77f052b-6f1e-440e-83b1-e4b9655dc3f8","state":-2},"firstInsertRatio":0.4,"width":282.8,"height":334.4}},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"6f77c993-9c62-4973-bfa2-0d9152853943","children":[],"zIndex":26,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666331033901-820845e6-0c67-4ae6-a420-65f0bbf18fd1.png","naturalWidth":674,"naturalHeight":671,"uploadInfo":{"hash":"794840ed148304c2d039796d05bdb22fe9a4e957b25ba7b1541b5b479d8c0f60","fileName":"image.png","fileType":"image/png","fileSize":84986,"localTempSrc":"blob:https://www.yuque.com/a0145f59-98bb-4501-97b8-36e59bbaf7b4","state":-2},"firstInsertRatio":0.4,"width":269.6,"height":268.40000000000003}},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"bab01f39-7f86-4d4b-9d52-0da170801f05","children":[],"zIndex":25,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666331059651-b0230e08-87b2-4bbf-a3d4-c6d74cd2aa52.png","naturalWidth":1058,"naturalHeight":1144,"uploadInfo":{"hash":"83cce560d5c234dfc15711318c9037d09aa1b5c30f1abe79f0c1af9a0d738f42","fileName":"image.png","fileType":"image/png","fileSize":200618,"localTempSrc":"blob:https://www.yuque.com/09265f87-28e6-43a4-89fe-b1db0413f725","state":-2},"firstInsertRatio":0.4,"width":423.20000000000005,"height":457.6000000000001}}],"zIndex":29,"html":"System Calls","collapsed":true}],"zIndex":249,"layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"capsule"},"html":"Overview","collapsed":true,"icons":{"progress":6}},{"html":"Process Management","layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"treeEdge":{"stroke":"#6F81DB"},"id":"4ae58ac1-2f4f-4d07-88e2-02410d9ad195","children":[{"id":"067d05f3-b30f-4498-8110-ab5ac26a5a5b","html":"进程","children":[{"border":{"shape":"capsule"},"id":"5fda9836-4f40-4ff1-8613-9b38324a8d58","children":[{"border":{"shape":"line"},"id":"8a153fd5-553a-4f49-b160-ef0920c6b6f4","children":[],"zIndex":52,"html":"<span style=\"font-weight:bold;\">进程 (Process)</span> 是被加载到内存中、正在运行的程序。多个进程可能对应同一个程序。一个正在运行的 OS 中会有多个进程。<div>进程是程序的一次执行过程，<span style=\"font-weight:bold;\">是操作系统分配资源的基本单位</span>。</div>"},{"html":"由于历史原因，进程 process 和 作业 job 这两个概念可以认为是等同的。","border":{"shape":"line"},"id":"94c235f5-d2bc-41fb-b728-69be38c73227","children":[],"zIndex":51},{"html":"一个进程包括……","border":{"shape":"line"},"id":"8e2e719d-97ca-49e8-949b-aab503a37057","children":[{"border":{"shape":"line"},"id":"2c5d8f70-09fe-434f-bb2f-638eedba1b7d","children":[],"zIndex":42,"html":"<span style=\"font-weight:bold;\">code (text)</span>，<span style>即程序代码，加载到内存前以 executable file 的形式存储在 disk 中</span>"},{"html":"<span style=\"font-weight:bold;\">program counter</span><span style>，指向下一个要运行的指令</span>","border":{"shape":"line"},"id":"99f02034-ebef-45d8-96ce-b60112e004ff","children":[],"zIndex":41},{"html":"content of the processer's <span style=\"font-weight:bold;\">registers&nbsp;</span>","border":{"shape":"line"},"id":"aef120a4-2200-4bd4-a096-f0235344fcc8","children":[],"zIndex":40},{"html":"<span style=\"font-weight:bold;\">runtime stack</span>，由用户代码操控（编译时完成关于栈的相关调用），在调用函数时暂时存储一些数据，如 local variables, return address, return values, state of registers, parameters 等。其中的条目称为 activation records (stack frames)","border":{"shape":"line"},"id":"e4bfd20f-55d0-4d17-8c0e-ea258d63c083","children":[],"zIndex":39},{"html":"<span style=\"font-weight:bold;\">data section</span>，存&nbsp;<span style>static variables</span>","border":{"shape":"line"},"id":"589290bb-62bb-4dc5-a918-8c583ea29583","children":[],"zIndex":38},{"html":"<span style=\"font-weight:bold;\">heap</span>，动态分配的内存","border":{"shape":"line"},"id":"92ce5c3e-5716-4022-9690-f812c947cfd2","children":[],"zIndex":37},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"fdb40f9a-ed74-4ae2-8043-5d2ac555de0b","children":[],"zIndex":36,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666334762398-3d101ac5-8cb1-435e-8a3f-1ccbf9a5b4a9.png","naturalWidth":529,"naturalHeight":576,"uploadInfo":{"hash":"467effb37d194852d2e82cfe218730172b86f1e8966b98ab5195781668ba13b4","fileName":"image.png","fileType":"image/png","fileSize":18066,"localTempSrc":"blob:https://www.yuque.com/3333b3dd-b366-488a-b729-47c64bc27028","state":-2},"firstInsertRatio":0.4,"width":211.60000000000002,"height":230.40000000000003}},{"html":"<div style=\"text-align:center;\"><span style>Executable and Linkable Format</span></div>","border":{"shape":"line"},"id":"8f7f2e5a-af0f-40b0-a0f9-6b71d331b65e","children":[],"zIndex":35,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666335577280-86ec36bb-6aef-4d42-9191-4b0f484f231a.png","naturalWidth":770,"naturalHeight":664,"uploadInfo":{"hash":"152fa6e9b7595fc4914f41bb40dd93c8d8f237a0b3becafa7087314867703b1c","fileName":"image.png","fileType":"image/png","fileSize":186979,"localTempSrc":"blob:https://www.yuque.com/7ce7ad86-f3f2-4a34-8130-216975b9eaf9","state":-2},"firstInsertRatio":0.4,"width":308,"height":265.6}},{"html":".data: 初始化了的静态变量<div>.bss: block starting symbol，未初始化的静态变量。ELF 里只会存这个段的长度，加载到内存时会占用对应大小的空间，初值为 0</div>","border":{"shape":"line"},"id":"aae60f56-0256-40e8-9461-0ac6f6976ece","children":[],"zIndex":34},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"42e0a7c3-7745-4cd0-80b8-66b4b6731bbd","children":[],"zIndex":33,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666335923708-cfd5b7e0-ce0d-45d9-9436-275d4dd09ab9.png","naturalWidth":1236,"naturalHeight":623,"uploadInfo":{"hash":"7d3ca050d0128a9a686e6bcd0d05bb61982921c5171e92a09817d86ed2516dd9","fileName":"image.png","fileType":"image/png","fileSize":86703,"localTempSrc":"blob:https://www.yuque.com/39d2b322-6792-4d70-abdf-90616895a487","state":-2},"firstInsertRatio":0.4,"width":480,"height":241.94174757281556}}],"zIndex":50,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"一个进程可能处于……","border":{"shape":"line"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"id":"7e91ef3a-a71c-4c92-b0bc-15da1ea48d7c","children":[{"border":{"shape":"line"},"id":"14ee5be2-a497-41f3-baeb-914bb94462d2","children":[],"zIndex":44,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666337791543-895bcfb6-e68e-4044-a88f-3b710e790b52.png","naturalWidth":718,"naturalHeight":345,"uploadInfo":{"hash":"b085acb98652d5e96fac93592fad1a12a3da8273514bd0f053ce384da45c0a59","fileName":"image.png","fileType":"image/png","fileSize":53268,"localTempSrc":"blob:https://www.yuque.com/351c34ca-3c77-4d57-a367-702474752968","state":-2},"firstInsertRatio":0.4,"width":381.6297062362859,"height":183.3736053642321},"width":437.85278871653804,"height":191.3736053642321,"html":"<div style=\"text-align:center;\"><span style></span></div>"},{"html":"一个处理器上，只有一个进程可以 running，更多的进程可能处于 ready 或 waiting 状态","border":{"shape":"line"},"id":"efbd19f5-d0ff-4fd1-a3c4-da5f6119aaf1","children":[],"zIndex":43}],"zIndex":49,"collapsed":true},{"border":{"shape":"line"},"id":"9f92a3f6-8dee-4140-8db6-2f36bb31383e","children":[{"border":{"shape":"line"},"id":"00df759f-12f8-480c-8b0d-ba9e05a0afd8","children":[],"zIndex":47,"html":"<div style=\"text-align:center;\"><span style></span></div>","image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666340140679-a636eb36-74f4-4da9-8cec-5339ecafa070.png","naturalWidth":624,"naturalHeight":620,"uploadInfo":{"hash":"67755ab47acb4bfb83c438ae1fd19a06e383498d733fd8aff2df17e783091a60","fileName":"image.png","fileType":"image/png","fileSize":39778,"localTempSrc":"blob:https://www.yuque.com/b94ae2e4-088b-42bf-8822-18b1a9aab55e","state":-2},"firstInsertRatio":0.4,"width":249.60000000000002,"height":248.00000000000006}},{"html":"<div><span style=\"font-weight:bold;\">CPU registers</span>，存储所有进程相关的寄存器的值</div><div><span style=\"font-weight:bold;\">CPU scheduling information</span>，properities, scheduling queue pointers, etc.</div><div><span style=\"font-weight:bold;\">Memory-management information</span>，基地址、页表之类的</div><div><span style=\"font-weight:bold;\">Accounting information</span>，CPU 使用时间、时间限制等</div><div><span style=\"font-weight:bold;\">I/O status information</span>，分配给进程的 I/O 设备列表、打开文件列表等</div>","border":{"shape":"line"},"id":"2dd0fc56-1c68-4d70-b565-7520f1aac539","children":[],"zIndex":46},{"html":"不同的系统可能有不同的 PCB。Linux 中的进程用结构体 <span style=\"font-style:italic;\">task_struct </span>存储。","border":{"shape":"line"},"id":"ad5b6727-5f9a-4449-a119-4102ff9d1d41","children":[],"zIndex":45}],"zIndex":48,"html":"操作系统用&nbsp;<span style=\"font-weight:bold;\">Process Control Block (PCB, a.k.a. task control block)</span> 表示进程，每个进程有且仅有一个 PCB。PCB 包含许多当前进程的相关信息，如……","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1],"quadrant":1},"html":"进程是啥","collapsed":true,"zIndex":84},{"html":"进程的创建","border":{"shape":"capsule"},"id":"131a25b3-9694-4d3a-a920-9864beec58bf","children":[{"border":{"shape":"line"},"id":"c4038bd4-af11-4e7c-8953-8c30e5932976","children":[],"zIndex":66,"html":"大多数操作系统通过一个唯一的 <span style=\"font-weight:bold;\">进程标识符 (process indentifier, pid)</span> 来标识一个进程。一个进程在运行时可以创建新的进程，则它成为父进程，新建进程称为子进程；父进程的 pid 称为子进程的 <span style=\"font-weight:bold;\">ppid (parent's pid) </span>。这样进程会成为一个 <span style=\"font-weight:bold;\">进程树 (process tree)&nbsp;</span>"},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"32190f34-6171-4937-a439-3558e3690476","children":[],"zIndex":65,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666354308595-6907f76d-880e-465f-9c6f-74ba66a4216f.png","naturalWidth":1581,"naturalHeight":813,"uploadInfo":{"hash":"f7419ef3cde1504bf14b651991d19adea21bb202db33d8977503a69fa13c8fde","fileName":"image.png","fileType":"image/png","fileSize":124502,"localTempSrc":"blob:https://www.yuque.com/c8dde473-a1ed-48c1-aa2a-5f401ab3a74e","state":-2},"firstInsertRatio":0.4,"width":544.8363421709694,"height":280.1720089721683},"width":597.6300000000006,"height":288.1720089721683},{"html":"传统的 UNIX 系统用进程 <span style=\"font-weight:bold;\">init </span>(a.k.a System V init , 它的 pid 总是 1) 作为所有用户进程的根进程。系统启动后，进程 init 可以创建各种用户进程。在最近的 Linux 版本中， init 被 <span style=\"font-weight:bold;\">systemd </span>替换了。 systemd 功能类似 init ，但提供了更多服务。","border":{"shape":"line"},"id":"dd7ed20b-fad9-4387-8021-40d8f04b66b5","children":[],"zIndex":64},{"html":"当子进程被创建时，它会需要一定的资源（CPU 时间、内存、文件、I/O 设备等）来完成任务。它可以从操作系统那里直接获取资源，也可以从父进程那里继承（共享）一些资源。建立子进程时，父进程也可以向子进程传递一些初始化数据，例如父进程创建一个显示图片的子进程时，可以将该图片的路径或文件名等传递给子进程。","border":{"shape":"line"},"id":"c54b2091-af7f-45f3-8bcc-4f625f905d14","children":[],"zIndex":63},{"html":"UNIX 系统中可以使用系统调用 fork() 来创建一个新进程。这个新进程是父进程的一份拷贝，它们只有 pid 和 ppid 不同，另外子进程当前内存使用记录为 0，除此以外全部相同。 fork() 对父进程返回该子进程的 pid，而对子进程返回 0。","border":{"shape":"line"},"id":"9dbcd82a-5b56-4fa3-9e6a-84ae2d879aa7","children":[],"zIndex":62},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"id":"3daa326d-4a8b-44d5-a96a-e6ad2cee791b","children":[{"border":{"shape":"line"},"id":"07da7a6b-d5a5-4bab-bdfd-d2086211d9a2","children":[],"zIndex":53,"html":"fork()  如何对父进程和子进程返回不同的值？<div><br></div><div>一种实现方式是，在进入 fork() 时存下当前的 pid，在建立新进程后（此时存下子进程的 pid），父进程和子进程都将分别完成 fork() 剩余代码的执行。在进行返回时， fork() 检查当前的 pid 与前面存下的是否一致，如果一致则说明当前是父进程，返回子进程的 pid；不一致则说明是子进程，返回 0。</div>"}],"zIndex":61,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666364612960-88b3f880-8da3-4ecc-bed2-364bf3a6cbe8.png","naturalWidth":1230,"naturalHeight":1224,"uploadInfo":{"hash":"ada3616c6b5316159abfd34f8f5a24952e33bbb7f706fd6827e3790689327235","fileName":"image.png","fileType":"image/png","fileSize":139077,"localTempSrc":"blob:https://www.yuque.com/08dfb5d3-edca-40dd-8034-3b6c236704bc","state":-2},"firstInsertRatio":0.4,"width":501.0859820556643,"height":498.64166019197813},"width":517.0859820556643,"height":573.2700000000007,"collapsed":true},{"html":"也就是说，当进程创建新进程时，父进程可以<div>&nbsp; ○ 继续运行（和子进程并发执行，即同时或者交替运行），或者</div><div>&nbsp; ○ 等待子进程运行完后再运行</div><div>子进程的地址空间有可能</div><div>&nbsp; ○ 使用父进程的一份拷贝，或者</div><div>&nbsp; ○ 加载另一个新的程序</div>","border":{"shape":"line"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"id":"9c6ff754-8f61-42b4-8f20-f5b0760a98dc","children":[{"border":{"shape":"line"},"id":"0c42fe63-9baf-4359-98c2-fa0edc7a5faf","children":[],"layout":{"quadrant":1},"zIndex":56,"html":"为什么要拷贝一份呢？考虑这样的代码：<a href=\"https://godbolt.org/z/78a8sTKhP\" target=\"_blank\">https://godbolt.org/z/78a8sTKhP</a>，子进程虽然和父进程跑的是一样的代码，但是不应当使用同一份数据。","width":554.9719641113288},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"995567c8-e912-4f75-85a1-51ed538daea5","children":[],"zIndex":55,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666365856780-686a6b46-7c4b-4c20-94ed-2cdcbff728ce.png","naturalWidth":2110,"naturalHeight":785,"uploadInfo":{"hash":"edadfbdf15aed3d604ecf8001f1dfe88a8a3a30e6a19625b4641e25628d3f44d","fileName":"image.png","fileType":"image/png","fileSize":179360,"localTempSrc":"blob:https://www.yuque.com/9e4fb384-5aff-4186-8625-a7db7f3f800e","state":-2},"firstInsertRatio":0.4,"width":590.4219641113291,"height":219.65935631630018},"width":606.4219641113291,"height":255.11999999999853},{"border":{"shape":"line"},"id":"9d8fede3-8f41-4927-a290-8f56c717d4b6","children":[],"zIndex":54,"html":"聪明的小朋友可能会问了，上面这种代码，child 将当前地址空间拷贝一份岂不是很浪费吗？因为根本没有用到。确实如此，因此部分 UNIX 的实现引入了 copy-on-write 机制，将地址空间的复制推迟到需要写入的时候再进行。"}],"zIndex":60,"collapsed":true},{"html":"UNIX 对启动新进程的逻辑是简单的。<span style=\"font-weight:bold;\">fork</span>&nbsp;的意义就是制造当前进程的一个副本，而 <span style=\"font-weight:bold;\">exec</span>&nbsp;的意义是用一个新的程序替代当前的进程。（<a href=\"https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec/1653415#1653415\" target=\"_blank\" style>Link</a>）","border":{"shape":"line"},"id":"c0191079-6a56-470d-b194-b4c102935e15","children":[],"zIndex":59},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"7a5e462f-958a-4da8-a6cf-8b36f29d8ae9","children":[],"zIndex":58,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666366177794-45abd85c-a392-421d-9150-5c9feb9d4e2b.png","naturalWidth":879,"naturalHeight":1119,"uploadInfo":{"hash":"9624db15984c5f6fbf1ecb4c0489bffc19ec0b14dcfbe09935acb761f72943f1","fileName":"image.png","fileType":"image/png","fileSize":56915,"localTempSrc":"blob:https://www.yuque.com/fb03534f-42e7-441d-9330-8e85c2175f9d","state":-2},"firstInsertRatio":0.4,"width":351.6,"height":447.6}},{"html":"系统调用 getpid() 和 getppid() 可以分别获取进程的 pid 和 ppid。","border":{"shape":"line"},"id":"bf74b5dd-71e9-4984-a432-34121cbeb675","children":[],"zIndex":57}],"collapsed":true,"layout":{"quadrant":1},"zIndex":83},{"html":"进程的终止","border":{"shape":"capsule"},"id":"1094156a-0171-47b6-83ba-be00a1f827b5","children":[{"border":{"shape":"line"},"id":"f9252ab0-877f-4f3e-8523-722bfff30eaa","children":[],"zIndex":71,"html":"系统调用 <span style=\"font-weight:bold;\">exit() </span>会使得进程终止。C 语言 main 函数返回时也会隐式地调用 exit()。除此之外，进程也会由于一些信号、异常等终止。"},{"html":"前面的代码中展示了 <span style=\"font-weight:bold;\">wait() </span>的系统调用，它使得当前进程进入 waiting 状态，并在任一子进程终止，或被信号停止，或被信号恢复时进入 ready 状态，同时返回发生该事件的子进程的 pid。","border":{"shape":"line"},"id":"f5bf63ba-32f0-4935-8764-f61ca575b3f0","children":[],"zIndex":70},{"html":"当一个进程终止时，它进入 terminated 状态，它的资源被操作系统回收。但是，操作系统仍然会保存一些信息（例如 PID，结束状态，资源使用情况等 <a href=\"https://man7.org/linux/man-pages/man2/waitpid.2.html#NOTES\" target=\"_blank\" style>Ref</a>），因为父进程有可能会需要调用 wait() 来获取其一些信息。当子进程已经终止，但父进程在忙，还没有调用 wait()，我们称这样的子进程为 <span style=\"font-weight:bold;\">僵尸进程 (zombie processes)</span>，因为前述信息仍然占据了进程表中的一项；如果表满了，就不能创建新的进程了。","border":{"shape":"line"},"id":"313f95ba-da3f-44bb-b003-642735908cb4","children":[],"zIndex":69},{"html":"当子进程没有结束，或者终止了但父进程没有调用 wait() 的情况下，父进程就结束了，子进程就会成为 <span style=\"font-weight:bold;\">孤儿进程 (orphan processes)</span>。一些操作系统会将孤儿进程一同终止掉，但是 UNIX 的做法是让 init 进程收养它们，即 init 进程成为其父进程。init 进程会定期调用 wait()，从而收集孤儿进程的退出状态，并释放进程表条目。","border":{"shape":"line"},"id":"9da98a67-4050-43dd-9d49-ce8c7494d626","children":[],"zIndex":68},{"html":"所以，如果我们想创建一个 <span style=\"font-weight:bold;\">守护进程 (daemon</span>，在后台运行的、生存期长的进程，例如 host 一项服务等<span style=\"font-weight:bold;\">)</span>，我们可以 fork 两次，让 grandchild 执行对应任务，而 child 直接终止，这样 grandchild 就会成为孤儿从而被 init 收养。","border":{"shape":"line"},"id":"42baf581-3c3a-4cd6-b5bb-f7e8b0ce9b83","children":[],"zIndex":67}],"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1],"quadrant":1},"collapsed":true,"zIndex":82},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"9c9c52bc-2084-4826-b347-392ffb6eea82","children":[{"border":{"shape":"line"},"id":"a25b078e-b1d8-4401-a6c0-57b48f2d42c7","children":[],"zIndex":80,"html":"<span style=\"font-weight:bold;\">进程间通信 (IPC, InterProcess Communication) </span>是为了在进程的资源相互隔离的情况下，让不同的进程能相互访问资源从而协调工作。"},{"html":"​主要有两种方式：<span style=\"font-weight:bold;\">共享内存 (shared memory)</span> 和 <span style=\"font-weight:bold;\">消息传递 (message passing)。</span>","border":{"shape":"line"},"defaultContentStyle":{"color":"#262626"},"id":"82b442ed-18c7-46b1-a4fa-dc631cfd92e7","children":[],"zIndex":79},{"html":"<div style=\"text-align:center;\"><span style></span></div>","border":{"shape":"line"},"id":"90f5442b-5cfb-4f16-ac12-e153b7d4f369","children":[],"zIndex":78,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666369523165-53e8c7c3-0a3e-4c3d-8ea1-dcd6ee7882a2.png","naturalWidth":997,"naturalHeight":671,"uploadInfo":{"hash":"278f8c7ba5663e2fbe383ba8ab91432d35fb4c689447980709cff56940f908e0","fileName":"image.png","fileType":"image/png","fileSize":51250,"localTempSrc":"blob:https://www.yuque.com/6910d65a-b712-48e7-9786-876a86df6e51","state":-2},"firstInsertRatio":0.4,"width":398.8,"height":268.40000000000003}},{"html":"<span style=\"font-weight:bold;\">信号量 (semaphores)</span>&nbsp;本意用来线程间同步，但是可以通过 <span style=\"font-weight:bold;\">sem_open()</span>&nbsp;系统调用来建立和维护进程间的信号量；这样的信号量属于 OS 资源，它会在相关进程结束后由 OS 释放 (<a href=\"https://www.man7.org/linux/man-pages/man3/sem_open.3.html\" target=\"_blank\" style>Ref1</a>, <a href=\"https://stackoverflow.com/questions/65390563/does-sem-open-allocate-memory\" target=\"_blank\" style>Ref2</a>)","border":{"shape":"line"},"id":"c4092160-eb38-4c40-9cd1-28bea80d1b06","children":[],"zIndex":77},{"html":"<span style=\"font-weight:bold;\">共享内存</span> 的实现是，两个进程各自有一块虚拟内存，映射到同一块物理内存。共享内存也需要信号量等同步手段保护。","border":{"shape":"line"},"id":"8cf319e6-b7f1-479c-9aa0-581d09d449c6","children":[],"layout":{"quadrant":1},"zIndex":76},{"html":"​<span style=\"font-weight:bold;\">共享文件。</span>","border":{"shape":"line"},"id":"f5c4f3f7-0942-405c-b869-462fd78e4473","children":[],"zIndex":75},{"html":"​<span style=\"font-weight:bold;\">管道 (pipe)。</span>管道的实现其实也是文件，创建管道时操作系统会返回两端的文件描述符；逻辑上实现的是一个半双工的信道。","border":{"shape":"line"},"defaultContentStyle":{"color":"#262626"},"id":"cc13327a-21cd-48cc-b5c5-2a8df68a1274","children":[],"zIndex":74},{"html":"​<span style=\"font-weight:bold;\">消息队列 (message queue)</span>。为什么需要消息队列呢？共享文件显然很慢，而共享内存比较难适用信息大小不等、信息读一次就失效等场景，且共享内存需要同步手段。消息队列可以解决这些问题。<div>消息队列，其实就是操作系统维护的一个一个的链表，进程可以新建或者连接到一个消息队列，并写入消息，或读取第一条满足一定条件的消息。</div><div>(<a href=\"https://www.tutorialspoint.com/inter_process_communication/inter_process_communication_message_queues.htm\" target=\"_blank\" style>Ref1</a>,&nbsp;<a href=\"http://www.science.unitn.it/~fiorella/guidelinux/tlk/node57.html\" target=\"_blank\" style>Ref2</a>)</div>","border":{"shape":"line"},"defaultContentStyle":{"color":"#262626"},"id":"d077bb77-d5b5-4d62-9a3c-9fc6d8716509","children":[],"zIndex":73},{"html":"<span style=\"font-weight:bold;\">​Socket。</span>TCP / UDP，适用于双方不一定在同一个计算机上的情况。","border":{"shape":"line"},"defaultContentStyle":{"color":"#262626"},"id":"0416db0c-db7f-4176-8c1e-a2991ae164c4","children":[],"zIndex":72}],"zIndex":81,"html":"进程间通信","collapsed":true}],"border":{"shape":"capsule"},"layout":{"quadrant":1,"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"zIndex":232,"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"2df2865b-3275-4067-bbd5-5d04b4e0af23","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2eedc161-2ebd-4aff-8f4f-df05c190251c","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"27b22783-35ae-435f-9371-8d6bdcf65572","children":[],"zIndex":86,"html":"​多道 (multiprogramming) 环境下，进程的个数通常大于 CPU 的个数。CPU 调度就是 OS 关于哪个 ready 进程可以运行（使用 CPU）以及运行多久的决定。"},{"html":"​其目标是始终允许某个进程运行以最大化 CPU 利用率，同时保证一定的公平性。这在多道环境下是必要的，关系到系统的整体效率。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e9572ef2-0920-4c75-9dd1-a29a7050fae3","children":[],"zIndex":85}],"zIndex":230,"html":"​CPU 调度是啥","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3597bd04-2744-4e30-acd7-b84c14d63f94","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d8f9e45b-84e5-4702-ab95-469a77d3d75f","children":[],"zIndex":141,"html":"​​​CPU 调度可能出现在某一个进程：\n<div>&nbsp; a. Running -&gt; Waiting，如等待 I/O\n</div><div>&nbsp; b. Running -&gt; Terminated</div><div>&nbsp;</div><div>&nbsp; c. Running -&gt; Ready，当发生了 interrupt，如计时器到时间了\n</div><div><br></div><div>&nbsp; d. Waiting -&gt; Ready，如 I/O 完成了</div><div>&nbsp; e. New -&gt; Ready</div>"},{"html":"​非抢占式 (nonpreemptive) 调度只会在 a, b 处进行调度，因为只有这时候当前正在运行的进程不能再运行了；抢占式 (preemptive) 调度会发生在上述任何时机。因此，抢占式调度使得 OS 有更充分的控制，但它也更复杂。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3a4c0a04-ba0e-4084-aae9-a4898c2c87fe","children":[],"zIndex":140},{"html":"​也就是说，当上述情况发生时，可以直接调用调度器来进行调度。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e666c52c-f22a-4c3f-be06-6e7336741c92","children":[],"zIndex":139}],"zIndex":229,"html":"​调度的时机","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"80ca20b9-d57c-4f54-a6ea-9a92c88994ab","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"72b76a14-7a14-418f-aad7-53ecac5f1673","children":[],"zIndex":88,"html":"<div style=\"text-align:center;\">&#8203;<br></div>","height":367.16051603618445,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666975181049-ff328bc1-9ca6-46bb-adf2-63e146271aeb.png","naturalWidth":1480,"naturalHeight":766,"uploadInfo":{"hash":"ad31c9e43879b90addba4c3815ab5a4b73aa6472350bb535ffb7912eb02f5a4d","fileName":"image.png","fileType":"image/png","fileSize":130467,"localTempSrc":"blob:https://www.yuque.com/d51c3033-917d-4769-accb-77c9dc3fe135","state":-2},"firstInsertRatio":0.8,"width":617.7578638980281,"height":319.73143496343886},"width":633.7578638980281},{"html":"​这个过程叫 <span style=\"font-weight:bold;\">上下文切换 (context switch)</span>，这里的上下文其实就由 PCB 来表示。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"12fa15b9-f434-4a91-9dbd-7b2d8e2c2d3f","children":[],"zIndex":87}],"zIndex":228,"html":"​调度的过程","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c306a366-b8b6-41c7-8f22-41b7e64c018a","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a9335f31-c3ba-4672-bef7-c33d0fd1eb76","children":[{"html":"Maximize CPU Utilization : CPU 使用率，即 CPU 非空闲的时间比例","children":[],"id":"1a9f95e8-f3f0-4773-a77e-46c652daf247","zIndex":93},{"html":"Maximize Throughput : 吞吐量，每个时间单元内完成的进程","id":"4a66d173-8c0c-40e6-8d1f-41637a810f10","children":[],"layout":{"quadrant":1},"zIndex":92},{"html":"Minimize Turnaround Time : 周转时间，从进程创立到进程完成的时间，包括等待进入内存、在 ready queue 中等待、在 CPU 上执行、I/O 执行等时间","id":"e53c066c-e4c3-43cc-b6a5-e044ad805397","children":[],"layout":{"quadrant":1},"zIndex":91},{"html":"Minimize Waiting Time : 等待时间，在 ready queue 中（或在 Ready 状态下）等待所花的时间之和","id":"91f0dca6-28bf-43df-a0aa-d24607c8a0a9","children":[],"layout":{"quadrant":1},"zIndex":90},{"html":"Minimize Response Time : 响应时间，交互系统从进程创立到第一次产生响应的时间","id":"55cbca33-6a93-4ab7-9341-ea73d5aaeaf8","children":[],"layout":{"quadrant":1},"zIndex":89}],"zIndex":95,"html":"对于不同的应用场景，我们对 scheduling 的要求也有所不同，有些也会有冲突。为此，我们需要充分考虑各种算法的属性。我们可能需要的要求包括：","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​这些要求有时甚至是冲突的。例如，较多的 context switch 会减少 throughput，因为 context switch 过程中并没有有用的工作；而较少的 context switch 会增加 response time。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3b16d987-4542-4457-ae17-5750643366de","children":[],"zIndex":94}],"zIndex":227,"html":"​调度算法的评价","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ab4eb169-9f11-4872-89ec-f98b128e9a1b","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7b20a4fb-78b2-44ed-90cf-825caaeaf5e6","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"546b0088-9792-4bfc-a68f-99a685bbb209","children":[],"zIndex":99,"html":"​先申请 CPU 的进程首先获得 CPU。可以用一个 FIFO 队列简单实现。"},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"238eaad2-accc-43b8-b7fa-c386d3028100","children":[],"zIndex":98,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666977030770-8aae7a9f-f755-4f53-966d-c92d67def913.png","naturalWidth":831,"naturalHeight":794,"uploadInfo":{"hash":"9ef8be04173085037b1d2bd9de8e57b88e813f50eb8838e578895ef508579443","fileName":"image.png","fileType":"image/png","fileSize":171396,"localTempSrc":"blob:https://www.yuque.com/08c52526-5d29-456c-a1b3-076239e36896","state":-2},"firstInsertRatio":0.8,"width":480,"height":458.6281588447653}},{"html":"​<span style=\"font-weight:bold;\">Convoy effect</span> - short process behind long process","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5971fc53-aa04-4b9b-ad0d-a1aa87049b77","children":[],"zIndex":97},{"html":"​尤其是当有进程进入 waiting 后，再返回的时候又需要重新排队","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a7098955-2727-4b01-b487-e9a77e95e2d2","children":[],"zIndex":96}],"zIndex":129,"html":"​First-Come First-Served (FCFS) | Nonpreemptive","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Shortest-Job-First (SJF)","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0bf713dd-7639-4840-bace-3beab96151ec","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"313a496a-0bd7-4fda-bb9c-abff4c55e26b","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"89d68138-833b-4d14-b2c0-1a12b57ac99e","children":[],"zIndex":101,"html":"​每当 CPU 调度时，其选取 ready queue 中下次 CPU 执行时间最短的进程。这样会使得给定的一组进程具有 minimum average waiting time."},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"efa0cdc5-052a-46a0-b06d-2812831a1213","children":[],"zIndex":100,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666977343474-4bc1d7ca-fdad-4489-89c8-2baaa1afb8e9.png","naturalWidth":982,"naturalHeight":636,"uploadInfo":{"hash":"8b219eef2f4c8e4360d2d415deff39aa28d62624631968c1d6d3426e41802416","fileName":"image.png","fileType":"image/png","fileSize":80194,"localTempSrc":"blob:https://www.yuque.com/b42d18d3-bdd5-4288-9cf5-93e3d1960078","state":-2},"firstInsertRatio":0.8,"width":480,"height":310.8757637474542}}],"zIndex":106,"html":"​Non-preemptive: Shortest-next-CPU-burst","collapsed":true},{"html":"​Preemptive: Shortest-remaining-time-first","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cb55be5d-543b-4a94-836f-b989337e839e","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"18c200e3-d1b4-4ab0-8a59-b6e68108b6d7","children":[],"zIndex":103,"html":"​每当 CPU 调度时（注意抢占式调度的调度时机），选择最短剩余运行时间的进程。"},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9bc8b34d-291f-4684-8e08-dfa053d15f5e","children":[],"zIndex":102,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666977521258-90ee6af3-3933-41c6-be14-59d60b1030ac.png","naturalWidth":973,"naturalHeight":660,"uploadInfo":{"hash":"2e078e7a0519cbb78090028d7ad83e06f8c8a5d0c03819b17590151e980c44e7","fileName":"image.png","fileType":"image/png","fileSize":82954,"localTempSrc":"blob:https://www.yuque.com/cdcdb3a3-f49e-48b4-9065-ae42ca78c857","state":-2},"firstInsertRatio":0.8,"width":480,"height":325.59095580678314}}],"zIndex":105,"collapsed":true},{"html":"​SJF 可以获得最小的平均等待时间，但最大的问题在于我们并不知道剩余的运行时间。解决方案是预测，将下次执行时间预测为此前 CPU 执行长度的指数平均。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e81539cc-bb16-47db-8613-40a1d42768f5","children":[],"zIndex":104}],"zIndex":128,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Round-Robin (RR) | Preemptive","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a504d975-e8c4-4115-8b25-ed7fac1d47bc","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"382383f2-e909-4e24-9c49-c038b47b4a2f","children":[],"zIndex":111,"html":"​定义一个 <span style=\"font-weight:bold;\">时间片 (time slice / time quantum) </span>，即一个固定的较小时间单元 (10-100ms)。除非一个 process 是 ready queue 中的唯一进程，它不会连续运行超过一个时间片的时间。Ready queue 是一个 FIFO 的循环队列。每次调度时取出 ready queue 中的第一个进程，设置一个计时器使得进程在一个时间片后发生中断，然后 dispatch the process。"},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1b67b3b6-6ef8-48ff-8d48-4b5c97c668d8","children":[],"zIndex":110,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666977971618-ebd18cac-5e14-4a9c-87d0-e7b821a1e80f.png","naturalWidth":979,"naturalHeight":437,"uploadInfo":{"hash":"d1b6fd03fc100571a21fd09456c739b6b09c7c7d61008dd9efb4dff4f0db8e1f","fileName":"image.png","fileType":"image/png","fileSize":38930,"localTempSrc":"blob:https://www.yuque.com/3efc6bed-6d62-4153-808c-5f1263eefb55","state":-2},"firstInsertRatio":0.8,"width":480,"height":214.2594484167518}},{"html":"​相比 SJF 而言，平均等待时间更长，但响应时间更短。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d5fa65ca-7c0a-4c1c-a985-23b0085933a0","children":[],"zIndex":109},{"html":"​RR scheduling 的性能很大程度上取决于时间片的大小。如果时间片较小，则 response/interactivity 会很好，但会有较大的 overhead，因为有较多的 context-switch；时间片较大则响应较差，但 overhead 会较小。如果时间片 -&gt; INF，则 RR -&gt; FCFS。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"025a4915-995c-45ae-9012-0b1ae49bfaa5","children":[],"zIndex":108},{"html":"​在实践中，时间片大约 10~100ms，每次 contest-switch 约 10μs。即 context-switch 的时间花费是比较小的。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"986ecdaf-e601-472f-a714-39f038b0f1e1","children":[],"zIndex":107}],"zIndex":127,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Priority Scheduling","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"e4487a18-35b8-4ffc-8bd3-d7281242d580","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6c753ff8-dd57-4ef8-a126-1a5bc07a7156","children":[],"zIndex":118,"html":"​每个进程都有一个优先级，每次调度时选取最高优先级的进程。（下例中规定优先级值小的优先级高。）"},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5697ee2b-1c26-4eb3-9e1f-d7860be35215","children":[],"zIndex":117,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666978166362-4ad05b00-4741-4876-a27f-46868805de83.png","naturalWidth":1071,"naturalHeight":695,"uploadInfo":{"hash":"159f2ae2637a86ed8ddd100dac7f25011ebaa40024f1568cf2fbeeb9fd0f673a","fileName":"image.png","fileType":"image/png","fileSize":63507,"localTempSrc":"blob:https://www.yuque.com/0916d76e-3cc5-4610-81ed-bdff89d3fb27","state":-2},"firstInsertRatio":0.8,"width":480,"height":311.484593837535}},{"html":"​优先级可以是内部的或者外部的：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6372e79f-3b86-44cc-bf57-7301c979525d","children":[{"html":"internal: 一些测量数据，例如 SJF 是 Priority 的一个特例，即优先级由预测 CPU 运行时间决定。","children":[],"id":"cb3c7f70-8398-4692-a29c-7b0324a4f961","zIndex":256},{"html":"external: 由用户指定进程的重要性。","id":"83cd3a8d-560d-4dda-81ff-1223d34f1b2a","children":[],"layout":{"quadrant":1},"zIndex":255}],"zIndex":116,"collapsed":true},{"html":"​Priority Scheduling 也可以与 Round-Robin 结合，如：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8e5a5252-dbb7-454a-8b9f-21fe2ee4f791","children":[],"zIndex":115},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5f5d6276-d260-4f0f-a3e7-e21ee7d255cb","children":[],"zIndex":114,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666978282803-cf4f724a-8320-443a-8aa5-b1a5f1ac3aa4.png","naturalWidth":1150,"naturalHeight":661,"uploadInfo":{"hash":"0c75567dbb1c32472b7ab87757641d9215942aaf9ecc9a913544dad6d3608745","fileName":"image.png","fileType":"image/png","fileSize":95595,"localTempSrc":"blob:https://www.yuque.com/4c934cd3-738d-476f-8a9d-95b404793ad5","state":-2},"firstInsertRatio":0.8,"width":480,"height":275.89565217391305}},{"html":"​要实现 Priority Scheduling，可以简单地将 ready queue 用 priority queue 实现；priority queue 也可以是抢占式或非抢占式的，如 SJF 一样。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ba988841-c70b-4456-b0c9-36abed055323","children":[],"zIndex":113},{"html":"​Priority 的一个重要问题是 <span style=\"font-weight:bold;\">indefinite blocking / starvation</span> ，即低优先级的进程可能永远没有机会被执行。一个解决方法是 <span style=\"font-weight:bold;\">Priority Aging</span> ，即根据等待时间逐渐增加在系统中等待的进程的优先级。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"229d8242-eaab-46e8-b3db-e2e144a22a49","children":[],"zIndex":112}],"zIndex":126,"collapsed":true},{"html":"​Multilevel Queue Scheduling","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"2aa53060-2fb0-462c-baab-93666afbcf77","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e8363789-1890-4c14-90ee-83a35b34a815","children":[],"zIndex":120,"html":"​在实际应用中，进程通常被分为不同的组，每个组有一个自己的 ready queue，且每个队列内部有自己独立的调度算法。<div>例如，前台队列使用 RR 调度以保证 response，后台队列可以使用 FCFS。</div><div>同时，队列之间也应当有调度。通常使用 preemptive priority scheduling，即当且仅当高优先级的队列（如前台队列）为空时，低优先级的队列（如后台队列）中的进程才能获准运行。</div><div>也可以使用队列间的 time-slicing，例如一个队列使用 80% 的时间片而另一个使用 20%。</div><div>例如：</div>"},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"106a96a5-8c46-4b92-aa2e-a225280d656f","children":[],"zIndex":119,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666978426409-608e5af5-1e15-437a-891f-c7c2091eeb71.png","naturalWidth":832,"naturalHeight":444,"uploadInfo":{"hash":"a5ea9cd4711de790e7f78f2d5e39f809f00c8ed7511ce5a7eee38d75580b05fd","fileName":"image.png","fileType":"image/png","fileSize":82755,"localTempSrc":"blob:https://www.yuque.com/9421736c-1c31-4de2-9fbc-45296b9c55af","state":-2},"firstInsertRatio":0.8,"width":480,"height":256.15384615384613}}],"zIndex":125,"collapsed":true},{"html":"​Multilevel Feedback Queue Scheduling","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"f18d44f3-917a-49be-8192-08252d211b31","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d913f09c-9592-43fc-9aa2-687cfa2bf08d","children":[],"zIndex":123,"html":"​Multilevel Feedback Queue Scheduling 允许进程在队列之间迁移。这种算法可以有很多种实现，因为队列的数量、每个队列中的调度策略、队列之间的调度算法以及将进程升级到更高优先级/降级到更低优先级的队列的条件都是可变的。一个系统中的最优配置在另一个系统中不一定很好。这种算法也是最为复杂的。"},{"html":"​看这样一个例子：有三个队列 0, 1, 2，优先级逐次降低。当进程 ready 时被添加到 Q0 中，Q0 内部采用 RR Scheduling，的每个进程都有 8ms 的时间完成其运行，如果没有完成则被打断并进入 Q1；只有当 Q0 为空时 Q1 才可能被运行。Q1 内部也使用 RR Scheduling，每个进程有 16ms 时间完成其运行，如果没有完成则被打断并进入 Q2；只有当 Q1 也为空时 Q2 才可能被运行。Q2 内部采用 FCFS 算法。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2102cd71-9faa-486e-8e97-7860531bcd4b","children":[],"zIndex":122},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a7693381-c18a-4471-9999-c4b21a74b3e9","children":[],"zIndex":121,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666978469891-9ed084a5-c64f-49b2-b951-231e48396afe.png","naturalWidth":1161,"naturalHeight":400,"uploadInfo":{"hash":"3e1ce00815602e9d21c18d398928c349f1a4075dcb2748dd7b4051b2636d4ecd","fileName":"image.png","fileType":"image/png","fileSize":91639,"localTempSrc":"blob:https://www.yuque.com/5dcacccd-1457-4c8c-86d8-b6ca81a8b4ae","state":-2},"firstInsertRatio":0.8,"width":480,"height":165.37467700258398}}],"zIndex":124,"collapsed":true}],"zIndex":226,"html":"​调度算法","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"html":"调度","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1],"quadrant":1},"zIndex":233,"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"116c50f3-ac61-4c37-a465-f5af6f1ae561","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"79fbabbd-61f5-451a-9db6-37911c00474e","children":[{"html":"在进程一节中，我们看到了进程在 fork 时有较大的开销，也看到了 copy-on-write 等技术能够减少这些开销；在调度一节中，我们同样看到了上下文切换时会带来的开销。我们容易意识到，在很多情况下，若干进程可能共享一些内容，而操作系统本身如果知道这些共享，则可以减省新建进程的开销以及进程间切换的时延。因此操作系统引入了 <span style=\"font-weight:bold;\">线程 (threads)</span>。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"16b8c14f-c9ad-44e2-9531-ecce3e26e3e4","children":[],"zIndex":271},{"html":"​在 Linux 中，线程也被称为 <span style=\"font-weight:bold;\">轻量级进程 (LightWeight Process)</span>，这实际上是对线程非常恰当的一个描述。每个线程都有它自己的 thread ID, PC, register set 和 runtime stack。线程与同一进程的其他线程共享 code section, data section, heap, open files 以及 signals。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ffe70aa8-3cf8-4e4b-b39f-7d433d6d2149","children":[],"zIndex":270},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9d5ba85f-00a2-4f76-a68f-efedda6201e2","children":[],"zIndex":269,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666981348556-c3b9b11a-7886-4d77-9123-b67daafe1333.png","naturalWidth":852,"naturalHeight":554,"uploadInfo":{"hash":"4af8edf3d765182e56506eb9818fbba5b6d1a7296450f0a0c06b83cca01d6344","fileName":"image.png","fileType":"image/png","fileSize":57962,"localTempSrc":"blob:https://www.yuque.com/6fe53cc6-6f07-4104-b9a6-457b4b16cf11","state":-2},"firstInsertRatio":0.8,"width":480,"height":312.112676056338}},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"850048c0-72d3-400a-b114-d37e90f92f67","children":[],"zIndex":268,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666981585529-d8e4100e-b647-47aa-bfcf-cc245fcb3b89.png","naturalWidth":1146,"naturalHeight":737,"uploadInfo":{"hash":"4118695bba0df5ca94dfc493f33f2735fc560b57b2685e44bddc648a5624364f","fileName":"image.png","fileType":"image/png","fileSize":102613,"localTempSrc":"blob:https://www.yuque.com/a131dae3-32d4-40dd-95f4-01328b757ed9","state":-2},"firstInsertRatio":0.8,"width":480,"height":308.6910994764398}},{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a70133e1-c698-412b-8567-e0c4a4b4e464","children":[],"html":"​对于支持线程的操作系统，实际调度的是内核级线程而非进程。也就是说，线程是运行以及 CPU 调度的基本单元。（而进程是分配资源的基本单元。）","layout":{"quadrant":1},"zIndex":267}],"zIndex":135,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"​为什么要有线程","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b2b71662-d80b-4eb6-97d3-f568ce8099f7","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3c01f19b-312f-41d7-b2cf-0b57b3cc074a","children":[],"zIndex":276,"html":"​<span style=\"font-weight:bold;\">Economy</span>: 建立线程相比进程是很经济的，因为 code, data &amp; heap 已经在内存中了；另外在同一进程的线程间进行 context switch 时也会更快，因为我们不需要 cache flush。"},{"html":"<span style=\"font-weight:bold;\">​Resource Sharing</span>: 同一进程的线程之间天然共享内存，因此我们无需为它们编写 IPC；这也允许我们对同一块内存做并行的处理。但这也会引入风险。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"fe62b152-fcaa-4343-906d-c0ebc8a535f5","children":[],"zIndex":275},{"html":"<span style=\"font-weight:bold;\">Responsiveness</span>: 多线程的进程会有更好的响应性，即当一个线程 blocked 或者在做一些长时间的操作时，其他线程仍然能完成工作，包括对用户的响应。例如，在一个 client-server 结构中，我们用一个线程来响应客户端的请求。","id":"a08222b3-5177-4d80-92c2-6248f4a4bb9d","children":[{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"f4445cb5-e912-40c1-a14e-68ced964e9d4","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666981447204-d56d197c-555d-4786-8896-415f00963446.png","naturalWidth":694,"naturalHeight":296,"uploadInfo":{"hash":"d60ab52364da12bc36eaaa278004afc3f6900d6c23d1aeb1ac0995060790c5c8","fileName":"image.png","fileType":"image/png","fileSize":30177,"localTempSrc":"blob:https://www.yuque.com/0c453b62-991e-4f73-83d1-2fe9d7ff230b","state":-2},"firstInsertRatio":0.8,"width":480,"height":204.72622478386165},"zIndex":257}],"zIndex":274,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"<span style=\"font-weight:bold;\">Scalability</span>: 在多处理器的体系结构中，多线程进程可以更好地发挥作用，因为每个线程都可以在一个处理器上运行；而单线程进程只能在一个处理器上运行。","id":"a5ad051e-83fd-4369-b362-455dd313094d","children":[],"zIndex":273},{"html":"实际上，后两点对多个单线程进程也是适用的。但多线程进程相较而言更加经济和自然。","id":"05abc0c8-5067-40d7-98b4-2f773795b5e9","children":[],"zIndex":272}],"zIndex":134,"html":"​线程的优点","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"254cc3e4-01c6-4bfc-927c-985965180ffa","children":[{"html":"如果一个线程出现错误，那么整个进程都会去世（比如浏览器的一个网页挂了，那么可能整个浏览器都会挂）。","id":"1f62a58f-772b-4949-8fcf-2b459ba84064","children":[],"zIndex":279},{"html":"由于 OS 对每个进程地址空间的大小限制，多线程可能会使得进程的内存限制更加紧缩（这在 64 位体系结构中不再是问题）。","id":"507d5924-9b48-42c7-a940-17195011246c","children":[],"zIndex":278},{"html":"由于多个线程共享部分内存，因此内存保护会比较困难。","id":"129ca007-eaa1-483a-b496-2fd6023b9473","children":[],"zIndex":277}],"zIndex":133,"html":"​线程的缺点","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8cc750ad-0e9d-4877-914a-f7538e0b3079","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cdd8349b-4588-4d4d-a317-0709e4b5bc18","children":[],"zIndex":284,"html":"<div style=\"text-align:center;\"><span style>​</span></div>","image":{"src":"https://cdn.nlark.com/yuque/0/2022/jpeg/641515/1666983296201-86642c27-a551-4eea-af99-e55fcfdac926.jpeg","naturalWidth":1920,"naturalHeight":1182,"uploadInfo":{"hash":"df8c54a57c17637898b9d4fe8cffdb67fd950f1d024612f2135e290e3b1647ed","fileName":"181797CBCE2A27FC90F0568DDB50CF67.jpg","fileType":"image/jpeg","fileSize":173614,"localTempSrc":"blob:https://www.yuque.com/926d6d87-33dc-4e6d-be86-520ba2067f2c","state":-2},"firstInsertRatio":0.8,"width":480,"height":295.5}},{"html":"​线程实现的重点是共享一些资源；而具体的实现分为 <span style=\"font-weight:bold;\">用户级线程 (User-Level Thread) </span>和 <span style=\"font-weight:bold;\">内核级线程 (Kernel-Level Thread)</span>&nbsp;两类。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"82da8c89-dade-4453-be58-5b2fe0f6636b","children":[],"zIndex":283},{"html":"用户级线程的特点是，它在操作系统上只是一个进程，这个进程包含 <span style=\"font-weight:bold;\">线程库 (Thread Library)</span> 的部分，​这部分代码负责完成线程的创建、切换等操作；而内核级线程则是由操作系统支持这些操作。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ff378722-a866-42cf-85de-c4bf8594a48d","children":[],"zIndex":282},{"html":"​用户级线程的优点包括：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"9f606da4-6847-4179-a856-27d1e9e79b8e","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9f18c1fa-9b1a-48fc-9126-bc831b136b35","children":[],"zIndex":260,"html":"​它并不实际占用操作系统的 TID (Thread ID) 等资源，因此理论上来说可以支持比内核级线程更多的线程数；"},{"html":"​它的调度等操作代码均在用户态，不需要进入内核态；","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"db0869eb-1505-4e0d-8149-9cd2b88371a3","children":[],"zIndex":259},{"html":"​比较容易实现自定义的调度算法。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"84e4bd79-022d-4453-8889-462a7db33231","children":[],"zIndex":258}],"zIndex":281,"collapsed":true},{"html":"​用户级线程的缺点包括：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f45b0058-623c-4b9e-98a6-561ba5721dfb","children":[{"html":"一旦当前正在运行的线程阻塞，那么在操作系统看来就是整个进程被阻塞了，那么同一个进程中的其他线程也同样会被阻塞；而如果是内核级线程的话，一个线程阻塞了，其他线程仍然能正常运行。","id":"e7513289-0b96-4ad7-9dc5-be0e61a42494","children":[],"zIndex":262},{"html":"同一个进程中的多个用户级线程无法在多核上分别运行。","id":"85d68e64-3572-4e1e-8f19-17b9b63ddc85","children":[],"zIndex":261}],"zIndex":280,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":132,"html":"线程的实现方式","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1bc3c7a6-a213-413e-8698-63fc0c6b7a3c","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"df705338-e40e-42fd-9ec9-e8506040b4f7","children":[],"layout":{"quadrant":1},"zIndex":266,"html":"​在同时支持用户级线程和内核级线程的系统中，用户级线程到内核级线程的映射方式有多种选择。"},{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"863baa19-6bc4-4262-bd5e-b1cfdbfdf9d9","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666983967148-f2457ebf-bf57-4d26-b1d9-7ee74c816bba.png","naturalWidth":503,"naturalHeight":339,"uploadInfo":{"hash":"7308f80193d972316d97528be50947ab7f7efffb8ade24309c528521ed4c064e","fileName":"image.png","fileType":"image/png","fileSize":31822,"localTempSrc":"blob:https://www.yuque.com/66620bfb-114b-4d7a-9e02-9f5f27cd82c9","state":-2},"firstInsertRatio":0.8,"width":321.6465386537414,"height":216.77569901315775},"width":409.5589461936106,"height":249.77569901315775,"html":"<div style=\"text-align:center;\"><span style>​</span><span style>​这种方式其实和只支持用户级线程没啥区别</span></div>","layout":{"quadrant":1},"zIndex":265},{"html":"<div style=\"text-align:center;\"><span style>​这种方式和只支持内核级线程也没啥区别</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"1f93d442-4373-4b7c-a4a6-7874f524c841","children":[],"zIndex":264,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666984146390-3dbe9c0d-654c-4dd1-9d6a-a0303f9f3273.png","naturalWidth":494,"naturalHeight":342,"uploadInfo":{"hash":"0f17bf5af3a7a485e335d4215298a48bb13c99ac6d958d575fe22276d69da003","fileName":"image.png","fileType":"image/png","fileSize":32161,"localTempSrc":"blob:https://www.yuque.com/2786f84c-d40c-4726-92c8-09792fa8b7df","state":-2},"firstInsertRatio":0.8,"width":395.20000000000005,"height":273.6}},{"html":"<div style=\"text-align:center;\"><span style>​​​前面两种的组合，在这种情况下，n 个用户级线程可以映射到 m (&lt;= n) 个内核级线程上。</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"756c30b7-2e86-41e9-9d29-194c9eafb19f","children":[],"zIndex":263,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666984197451-6832aa35-764c-4a64-ab93-23e114ac5142.png","naturalWidth":470,"naturalHeight":337,"uploadInfo":{"hash":"b968459083527a4333f704194c0d6e01cc905ce532729c0873d1e8b1eaa55f39","fileName":"image.png","fileType":"image/png","fileSize":36920,"localTempSrc":"blob:https://www.yuque.com/0e5860c4-e1c1-4151-abae-a75be289aba1","state":-2},"firstInsertRatio":0.8,"width":376,"height":269.6}}],"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"zIndex":131,"html":"​多线程模型","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cc2daa60-ae93-4132-be1f-c2e4a2090999","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f5e450e4-43c6-4dc0-8025-46d08cf686b6","children":[],"zIndex":291,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"​Linux 中没有特别区分进程和线程，它们都被称为 tasks，每一个线程都有一个 task_struct。（虽然从概念上说，线程应该都使用其所属进程的 PCB，但是 Linux 不是这么实现的！）"},{"html":"​Linux 中可以通过 clone() 新建一个线程；这个系统调用包含了一大堆选项，包括新建的是一个线程还是进程，以及继承 / 新建哪些资源等。事实上，在很多实现中，fork() 的内部就是调用 clone() 实现的。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"64b763fe-8870-4a05-9099-ddab94650313","children":[],"zIndex":290},{"html":"​从用户视角而言，Linux 中的线程通过 TID (Thread ID) 标识，而来自同一个进程的多个线程应当具有同样的 PID (Process ID)；系统调用 gettid() 和 getpid() 的实现和这个理解是一样的。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"efa1a77e-1e08-49dc-8db4-a21e238e27e8","children":[],"zIndex":289},{"html":"​但是事实上，task_struct 里面并没有 tid 这个字段，而是有 pid 和 tgid (Thread Group ID) 这两个字段。其实，这里的 pid 和我们前述的 TID 含义一致，而这里的 tgid 和前述 PID 含义一致。这主要是历史原因，在还不支持线程的年代，pid 作为调度的依据被使用；在支持多线程后，调度的单元从进程变为了线程，如果引入一个新的字段 tid，则需要修改相关的代码，因此 pid 被保留，但发挥 tid 的作用；引入了一个新的字段 tgid，表示这一组线程的标识符，也就是其所属进程的标识符。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"117c677c-7875-47d7-8a60-c00aa1c31fd6","children":[],"zIndex":288},{"html":"<div style=\"text-align:center;\"><span style><a href=\"https://stackoverflow.com/a/9306150/14430730\" target=\"_blank\" style>​Src</a></span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"57cdca21-986d-45bf-8c5c-375de7960edf","children":[],"zIndex":287,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666985261195-8bfbb610-f762-4ee7-b27c-6da4d01ad340.png","naturalWidth":550,"naturalHeight":440,"uploadInfo":{"hash":"c2e83b14988a0a19e3c0b06edc80612c47c327d641dfde6516998cf5e2cbb4d3","fileName":"image.png","fileType":"image/png","fileSize":14173,"localTempSrc":"blob:https://www.yuque.com/13aad600-97cb-429c-b114-43b58499c32b","state":-2},"firstInsertRatio":0.8,"width":440,"height":352}},{"html":"​正因如此，从 Linux 2.4 开始，getpid() 返回的就不再是 pid 了，而是 tgid。(<a href=\"https://man7.org/linux/man-pages/man2/clone.2.html\" target=\"_blank\" style>Ref, 参见 CLONE_THREAD 一节</a>)","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1bcae74e-3e80-4c37-8aab-3d8e5845adee","children":[],"zIndex":286},{"html":"​使用 ps 指令，还能看到一个名叫 LWP (LightWeight Process) 的值，这个值始终和 TID 的值相同；LWP 通常被用作给用户呈现，而 TID 更经常被用作 gettid() 之类的系统调用。还有一个字段叫 NLWP，表示进程中的线程个数。(<a href=\"https://www.baeldung.com/linux/pid-tid-ppid#2-tid-thread-identifier\" target=\"_blank\" style>Ref</a>)","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0bb4d9a5-24b6-4de7-b625-07a4a885606b","children":[],"zIndex":285}],"zIndex":130,"html":"​Linux 线程","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":231,"html":"线程","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":251,"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"icons":{"progress":6},"collapsed":true},{"html":"Process Synchronization","layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#6EC4C4"},"id":"a485b91d-cf0d-41e9-b698-347d3a1e9abf","children":[{"id":"902c84bf-0998-4b71-9971-24dcf8c15d81","html":"​同步","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"c7f87739-d96e-4d52-ab7c-673551b5c9c7","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d523c022-f5e5-4478-adde-1484077c0a62","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e3cb7385-d186-4ed2-9362-8a3e7091c52c","children":[],"zIndex":166,"html":"​我们说 <span style=\"font-weight:bold;\">Cooperating Process</span> 是可以影响系统中其他进程或被其他进程影响的进程。"},{"html":"​Cooperating processes 会共同使用一些数据，可能是直接使用同一段地址空间（代码+数据），或者是通过共享的内存或信息传递来共用一些数据。对数据的并发访问 (concurrent access) 可能会导致 data inconsistency，因为数据的一致性需要 cooperating processes 有序的运行。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5eb5392a-c68f-4435-ab39-c5809b73d5ea","children":[{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"ac646394-3870-4b29-8813-f81677e3ab19","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667052116167-b3fdf238-36ed-45ce-a5f0-5bf30b1404fa.png","naturalWidth":485,"naturalHeight":538,"uploadInfo":{"hash":"9e3af416d5294316f0dd47c1a90862950c62961a6e35fac08c46cc48b9a19340","fileName":"image.png","fileType":"image/png","fileSize":36144,"localTempSrc":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667052116167-b3fdf238-36ed-45ce-a5f0-5bf30b1404fa.png","state":-2},"firstInsertRatio":0.8,"width":388,"height":430.40000000000003},"zIndex":163},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"e4406fd5-7fca-4d77-ab31-f1eb05e90546","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667052257225-c9b441ac-f244-4487-88f3-f0fd2cbf668f.png","naturalWidth":755,"naturalHeight":383,"uploadInfo":{"hash":"2519eb6037a45f51101e13495cdcb3a5c8d8cccf46f0950240c54acb9b9fa936","fileName":"image.png","fileType":"image/png","fileSize":65100,"localTempSrc":"blob:https://www.yuque.com/bd112ffa-443b-4aa4-bcb4-1d1e820b5f9b","state":-2},"firstInsertRatio":0.8,"width":480,"height":243.49668874172187},"zIndex":162},{"html":"<div style=\"text-align:center;\"><span style>​一种可能的运行顺序</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"f4626a8f-6b9a-42ff-bf4f-3fc2cc4f5ceb","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667052278199-406696ba-f633-4192-9874-8909ca44881b.png","naturalWidth":670,"naturalHeight":170,"uploadInfo":{"hash":"f97c9478c8b9923dca7a0ed4d43f89a381c3706ba867c2eb7f1a40eb37157f66","fileName":"image.png","fileType":"image/png","fileSize":60028,"localTempSrc":"blob:https://www.yuque.com/fa25e76a-074a-40e6-9864-d161f20e6158","state":-2},"firstInsertRatio":0.8,"width":480,"height":121.79104477611939},"zIndex":161},{"html":"​出现这个问题，是因为我们允许两个进程同时操控变量 count 。类似这样的多个进程同时操控同一个数据，因而结果取决于每一种操控的出现顺序的情形，称为 <span style=\"font-weight:bold;\">race condition</span>。为了防止 race condition，我们需要保证同一时间只有一个进程可以操控某个变量。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"3a10f532-5818-4ddf-ab75-d10d426e8196","children":[],"zIndex":160}],"zIndex":165,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Race condition 在操作系统中是常见的。Kernel code 中也包含 race condition 的可能性。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b4b12f1c-2bd8-42f6-976a-b661435794f5","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8fee8b02-7e4b-46f3-803a-c4d91a530604","children":[],"zIndex":293,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667052344682-e82d911d-e1b1-4a1a-ab49-6dbcdda4d0df.png","naturalWidth":693,"naturalHeight":495,"uploadInfo":{"hash":"7c43a94764a0d166f20f881b855ec025de34932ccd9b80a5b586fb3e4cc30666","fileName":"image.png","fileType":"image/png","fileSize":42770,"localTempSrc":"blob:https://www.yuque.com/ab19e34c-febd-44b3-9ba6-fa554babc949","state":-2},"firstInsertRatio":0.8,"width":480,"height":342.8571428571429},"html":"<div style=\"text-align:center;\"><span style>​</span></div>"},{"html":"​两个进程 P0 和 P1 同时 fork() 时，如果不加限制，可能会出现类似前例的情况，即在某一个进程把当前的 next_avaliable_pid 分配给他的 child 后，在没来得及更新 next_avaliable_pid 前，另一个进程使用了 next_avaliable_pid 来给 child 分配 PID，这就会导致两个不同的线程使用同一个 PID 的情况。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6d017bb7-a23e-4979-8a2a-9e0cddc03dfa","children":[],"zIndex":292}],"zIndex":164,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":241,"html":"​为什么需要同步","layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"55cb78e6-77d7-41a0-9ad1-3504e6e608cd","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8e169593-45f1-4a66-b370-c091ad285b97","children":[],"zIndex":178,"html":"​考虑一个有 n 个进程的系统，每个进程中都有这样一段代码，它可能会修改一些与其他至少一个进程公用的数据，这段代码称为 <span style=\"font-weight:bold;\">critical section</span>。这个系统需要满足的重要性质是：当一个进程正在运行它的 critical section 时，其他进程都不能进入它的 critical section。"},{"html":"​我们将这个问题称为 <span style=\"font-weight:bold;\">Critical-section problem</span>，也就是要设计一种达成这一性质的方法；或者说，设计一种能让各个进程&nbsp;<span style=\"font-weight:bold;\">同步 (synchronize)</span>&nbsp;它们的活动，从而安全地共享数据的协议。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"720e03d0-17d5-4369-bfd4-d6481fae3124","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"64fff5e8-6fdf-4bd8-bfb2-e3cb463fbbf0","children":[],"zIndex":138,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"​同步的核心意义是，规定进程所做的工作之间的顺序或者先序关系，从而防止一些非法情况的发生。"}],"zIndex":177,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ab2079ec-adff-47f2-bbb3-14c9ffd4805a","children":[],"zIndex":176,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667289962374-faa23a13-fb29-4823-8b21-e6ffb34221bd.png","naturalWidth":693,"naturalHeight":627,"uploadInfo":{"hash":"3fa8e6aa61703d20e3c0c827cafda941c53fe3cb2381c5aa607ff357a3c3ef2a","fileName":"image.png","fileType":"image/png","fileSize":42692,"localTempSrc":"blob:https://www.yuque.com/a03256c3-32dc-4aa6-aaee-5f2be7fd8b37","state":2},"firstInsertRatio":0.4,"width":277.2,"height":250.79999999999995}},{"html":"​每个进程必须在 entry section 中申请进入 critical section 的许可；在 critical section 运行结束后进入 exit section，在这里许可被释放。其他代码称为 remainder section。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e0993665-6e11-4474-a9d5-fcac2d21abe0","children":[],"zIndex":175},{"html":"​Critical-section problem 的解决方法必须满足如下三个要求：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"3de7959e-84c4-43f3-bf4b-062f6cae2608","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"10f47f9f-a753-4ac8-9178-d587bc1b4a3f","children":[],"zIndex":169,"html":"​<span style=\"font-weight:bold;\">Mutual exclusion</span> - 没有两个进程可以同时在运行 critical section"},{"html":"​<span style=\"font-weight:bold;\">Progress </span>- 系统整体上是在运行的，即要么有进程在运行它的 critical section，要么没有任何进程想要（将要，即在运行 critical section 之前的 section）进入 critical section，要么在有限时间内将有一个进程被选中进入它的 critical section","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"bca73338-b229-4730-acc0-e45083b1da7d","children":[],"zIndex":168},{"html":"<span style=\"font-weight:bold;\">​Bounded waiting</span> - 任何一个进程等待进入 critical section 的时间是有限的。即，当一个进程提出一个进入 critical section 的请求后，只有有限个（次）进程会在它之前进入 critical section","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"912a4e02-4da7-4165-a386-ce6e4eba40c6","children":[],"zIndex":167}],"zIndex":174,"collapsed":true},{"html":"​对于单核系统，我们可以通过在 critical section 中禁止中断（即，在 entry section 中 disable，在 exit section 中 enable）的方式来实现上述功能（虽然可能是危险的）。​但是对于多核系统，中断禁止的消息要传到所有处理器，消息传递会延迟进入临界区，会降低效率；同时也会影响时钟中断。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"906f6678-98ff-44ce-a26b-48a8f494d691","children":[],"zIndex":173},{"html":"​我们需要保证 kernel 的设计实现了 critical section。Kernel 的实现分为两种类型，分别是 <span style=\"font-weight:bold;\">抢占式内核 preemptive kernel</span>&nbsp;和 <span style=\"font-weight:bold;\">非抢占式内核 nonpreemptive kernel</span>，其区别是是否允许处于 kernel mode 的进程被抢占。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8151e998-9e1b-43d2-8dbd-14e91f6ff581","children":[],"zIndex":172},{"html":"​（但是实际上，非抢占式内核的实现是保证同一个时间点只有一个进程能在 kernel 里跑 [<a href=\"https://unix.stackexchange.com/questions/412806/what-was-the-reason-of-the-non-preemptivity-of-older-linux-kernels\" target=\"_blank\" style>Ref1</a>, <a href=\"https://en.wikipedia.org/wiki/Giant_lock\" target=\"_blank\" style>Ref2</a>] ——这种实现和前面概念的区别是，有可能有多个处理器；如果按前面的概念来说的话，并不能保证没有多个 CPU 同时跑在 kernel 里。）因此，非抢占式内核不会导致 kernel mode 的 race condition，因为在任一时间点只有一个进程能在 kernel 里跑，所以 kernel 用到的各种数据和资源也就只有它一个人用了！","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"fcd58a8e-ffd7-45db-910d-f9be9dec608a","children":[],"zIndex":171},{"html":"​抢占式内核相对而言更难设计，但是同时也能有更快的响应。我们后面来讨论设计抢占式内核，或者说设计出解决了 critical-section problem 的程序的方案。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"16f400fb-4c77-4bfe-bb2e-ef42609f3645","children":[],"zIndex":170}],"zIndex":240,"html":"​问题建模","collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0fea6e36-b1fe-4553-9b98-984b80daba1f","children":[{"html":"​内容","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"332a3ff5-cd24-4b81-a377-e39c4a916526","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cab6c268-5718-4ad4-b3e6-dc5d02b48815","children":[],"html":"​Peterson's solution 基于一定的假设解决了两个 task 的 synchornization：","layout":{"quadrant":1},"zIndex":181},{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"20a187c1-ae71-4c83-8ec7-510da298b555","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667553858848-d5334f8b-12cd-4101-b4e1-0514365b9371.png","naturalWidth":779,"naturalHeight":362,"uploadInfo":{"hash":"0c3c589277553acc08f32a2c37f6d6b844ac2edefe3d68e370c4fee750147b46","fileName":"image.png","fileType":"image/png","fileSize":35443,"localTempSrc":"blob:https://www.yuque.com/328656bf-04df-4a44-878e-a8094934e82f","state":-2},"firstInsertRatio":0.8,"width":678.0701958955237,"height":315.0980884649289},"width":694.0701958955237,"height":336.75447469682854,"html":"<div style=\"text-align:center;\"><span style>​</span></div>","layout":{"quadrant":1},"zIndex":180},{"html":"​其中， i 是 0 或 1，表示第 i 个进程； turn 是当前有权进入 critical section 的进程（0 或 1）； flag[i] 是第 i 个进程是否准备好进入 critical section，初始值均为 FALSE。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"8cf20dbd-f9c6-4c9a-bd9d-27ce714d3b77","children":[],"zIndex":179}],"zIndex":185,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​性质证明","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3b65b766-f61a-475c-bc6f-013bd229c8a9","children":[{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"92cf4a7e-bcb5-4a78-89d3-ae6cd6b7054a","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667553954494-c4b92a49-89f2-4085-9536-c1ddc50e3be2.png","naturalWidth":1099,"naturalHeight":522,"uploadInfo":{"hash":"d2d5b3c80f84c9f5f6e44ef356b60553fafc99325f9f1b0dfaa9274411ee3870","fileName":"image.png","fileType":"image/png","fileSize":121897,"localTempSrc":"blob:https://www.yuque.com/3e6e4807-5879-4c04-b3e6-f9d95479f91c","state":-2},"firstInsertRatio":0.8,"width":480,"height":227.98908098271158},"zIndex":143},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"34388855-6e24-40df-bc90-fc3e7b425760","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667554010216-1d007332-e2a3-4d08-96df-0311d3cefb4c.png","naturalWidth":1227,"naturalHeight":726,"uploadInfo":{"hash":"cd977643ac5799795af0be9842ba31fdfe21bc7160cc86a0cf5e1bec69e60b7d","fileName":"image.png","fileType":"image/png","fileSize":100081,"localTempSrc":"blob:https://www.yuque.com/37c1f3ac-cc0a-4a29-bbbf-629996e4d749","state":-2},"firstInsertRatio":0.8,"width":480,"height":284.00977995110026},"zIndex":142}],"zIndex":184,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Reordering","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c29b21a1-71d6-45a3-a3e5-aaa143513c14","children":[{"html":"​但实际上，Peterson's solution 在现代计算机体系结构上不一定适用，因为现代的处理器和编译器有可能会为了优化性能而对一些读写操作进行重排。在优化中，处理器或编译器会考虑其重排的合理性，即保证了在单线程程序中结果值是稳定且正确的。但是这不能保证其在多线程共用数据时的正确性，重排可能会导致不稳定或者不期望的输出。例如如果编译器将对 flag[i] 和 turn 赋值的顺序交换：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"1a69134a-0bca-4ff4-88a6-eab9d4caa86f","children":[],"zIndex":151},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"52446a7a-b8d3-498f-a692-1b4310261266","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667556904700-e807cc82-225b-4602-aec2-469004add84f.png","naturalWidth":718,"naturalHeight":253,"uploadInfo":{"hash":"774fb8b1f30833cba2fe6ad3236861ad1f6d1e9f814489825a142e904c90874c","fileName":"image.png","fileType":"image/png","fileSize":28158,"localTempSrc":"blob:https://www.yuque.com/767bbbb1-6775-45ff-abc1-74304c503845","state":-2},"firstInsertRatio":0.8,"width":480,"height":169.13649025069637},"zIndex":150},{"html":"​Note that reordering of memory accesses can happen even on processors that don't reorder instructions (<a href=\"https://en.wikipedia.org/wiki/Peterson%27s_algorithm#Note\" target=\"_blank\" style>Src</a>)","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"880b2240-9185-4ebb-a416-7991098365ba","children":[],"zIndex":149},{"html":"​Memory Barrier","border":{"shape":"rect","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"a5d4951c-1553-46d2-a050-008742b604df","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aee7baf1-1c79-47d7-8384-df3a629c2bd7","children":[],"zIndex":147,"html":"​如我们之前所说，编译器和处理器会对代码的结构进行 reorder，以达到最佳效果。例如："},{"html":"<div style=\"text-align:center;\"><span style>​对 a2 和 b1 进行重排，使得不需反复读取交替 x 和 y 值</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d5c3eff9-27b9-47c2-ac72-e32cea1b045c","children":[],"zIndex":146,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667569641171-27c78c30-3270-43cc-a481-aeaff657a5c2.png","naturalWidth":508,"naturalHeight":341,"uploadInfo":{"hash":"8fa972a2c88396f8f1a39cf055620386ce6e4303a124798fc3a8d34588794a32","fileName":"image.png","fileType":"image/png","fileSize":23480,"localTempSrc":"blob:https://www.yuque.com/8d53a4a5-5cda-4361-8a6f-e4ec96952e15","state":-2},"firstInsertRatio":0.8,"width":406.40000000000003,"height":272.8}},{"html":"​重排可能使得在多核运行时出现与期望不同的结果。为了解决这个问题，我们引入 Memory Barrier：它用来保证其之前的内存访问先于其后的完成。即，我们保证在此前对内存的改变对其他处理器上的进程是可见的。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9669bc67-43b4-4290-b5a2-87b815f3a36d","children":[],"zIndex":145},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"fde62b85-6185-44f3-b612-0dcb1f7ded57","children":[],"zIndex":144,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667569907678-70839816-4ac1-47e2-94a8-3389fc85ba62.png","naturalWidth":823,"naturalHeight":398,"uploadInfo":{"hash":"d7aed9acf271277ba2d2417e5649cc1166e1e375b5784dfcd0ba205c13970015","fileName":"image.png","fileType":"image/png","fileSize":80088,"localTempSrc":"blob:https://www.yuque.com/b7cedebf-7fae-4705-93c8-b842dd982e2e","state":-2},"firstInsertRatio":0.8,"width":480,"height":232.12636695018224}}],"zIndex":148,"collapsed":true}],"zIndex":183,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Memory model","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a82214e0-e599-4b4a-9403-0fc80ccea40b","children":[{"html":"​另外，在现代的体系结构上，一个线程写了对应的变量后有可能不会立刻写回内存，这也有可能导致问题：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"608add1e-1ea3-4ae9-83a6-fa35d676235c","children":[],"zIndex":155},{"html":"How a computer architecture determines what memory guarantees it will provide to an application program is known as its <span style=\"font-weight:bold;\">memory model</span>. In general, a memory model falls into one of two categories:","id":"22f8cb30-2e08-4f8f-a9c1-da8efa40e2ac","children":[{"html":"1. <span style=\"font-weight:bold;\">Strongly ordered</span>, where a memory modification on one processor is immediately visible to all other processors.","id":"de893062-5810-40ce-9e45-c1904596d9d2","children":[],"layout":{"quadrant":1},"zIndex":153},{"html":"2. <span style=\"font-weight:bold;\">Weakly ordered</span>, where modifications to memory on one processor may not be immediately visible to other processors.","id":"c00f4c43-5dd4-496d-b166-f88dbb589a77","children":[],"layout":{"quadrant":1},"zIndex":152}],"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1],"quadrant":1},"collapsed":true,"zIndex":154}],"zIndex":182,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":239,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"html":"​Peterson's Solution","collapsed":true},{"html":"​Hardware Inst.","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1],"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"18350758-d649-4514-8977-79a112d53453","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"dc2fbe62-ee70-42be-992e-59f87422af93","children":[],"zIndex":197,"html":"​许多现代系统提供硬件指令，用于检测和修改 word 的内容，或者用于 <span style=\"font-weight:bold;\">atomically</span>（uniterruptably，不可被打断地） 交换两个 word。这里，我们不讨论特定机器的特定指令，而是通过指令 <span style=\"font-style:italic;\">test_and_set()</span> 和 <span style=\"font-style:italic;\">compare_and_swap()</span> 抽象了解这些指令背后的主要概念。"},{"html":"​test_and_set","border":{"shape":"rect","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"ac5673f9-b94c-4bc0-abd3-85740f65f2f2","children":[{"html":"<div style=\"text-align:center;\"><span style>​这一指令的重要要求是：它的执行是 atomic 的</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d118c3b8-5d9a-41a7-ba8d-1bc44ba2dbd0","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667571975556-734d791f-6f27-4787-9cf6-2d7f2c3ec3e0.png","naturalWidth":386,"naturalHeight":140,"uploadInfo":{"hash":"40a8efd7e61fcf5fa2fa1e46300b268d134b8f43de04fd1dc017dd346088db46","fileName":"image.png","fileType":"image/png","fileSize":9633,"localTempSrc":"blob:https://www.yuque.com/156e42cc-250c-4538-b373-6f7c320b476b","state":-2},"firstInsertRatio":0.8,"width":308.8,"height":112},"layout":{"quadrant":1},"zIndex":194},{"html":"​我们可以在支持这个指令的机器上实现 mutual exclusive：定义一个 bool 变量 lock ，初始化为 false。进程的结构为：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"14485348-d769-4d2f-b962-2de75680fd1c","children":[],"zIndex":193},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3a941f92-f485-4ee1-9dd4-daf88d1586c6","children":[],"zIndex":192,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667572108500-fd644ef5-3938-4ffd-8c9b-75198e154841.png","naturalWidth":364,"naturalHeight":303,"uploadInfo":{"hash":"ad799bd791aa1358120f6c21ea87b83bd73986fac5d33d686b6eaa928a1e9322","fileName":"image.png","fileType":"image/png","fileSize":18692,"localTempSrc":"blob:https://www.yuque.com/c2fe1179-a4e9-4462-8938-3138330463ee","state":-2},"firstInsertRatio":0.8,"width":291.2,"height":242.39999999999998}},{"html":"​可见，如果 lock 在 Entry Section 时为 true，那么 test_and_set(&amp;lock) 将返回 true，因此会始终在 while 循环中询问。直到某个时刻 lock 为 false，那么 test_and_set(&amp;lock) 将返回 false 同时将 lock 置为 true，进程进入 Critical Section，同时保证其他进程无法进入 Critical Section。当持锁的进程完成 Critical Section 的运行，它在 Exit Section 中释放 lock ，从而允许其他进程进入 Critical Section。<div>如果某个时刻 lock 为 false，而有两个或多个进程几乎同时调用了 test_and_set(&amp;lock) 。但由于它是 atomic 的，因此只有一个进程可以返回 false。</div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"820ff75f-17ad-409c-b1f7-a5d0c2fb823b","children":[],"zIndex":191},{"html":"​但是，如上所示的控制不能满足 bounded waiting 条件：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"004f1421-37b9-4a86-aa97-bccc4edf8f4c","children":[],"zIndex":190},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0e0282bb-194b-44f3-8a4b-fd39de8a4eab","children":[],"zIndex":189,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667572328986-9a77372b-a6ca-4ca4-ae1e-da79a146257c.png","naturalWidth":649,"naturalHeight":227,"uploadInfo":{"hash":"64eed431e720074b0097933814b2c354a46e2783f0f439dc8f980d77b345683c","fileName":"image.png","fileType":"image/png","fileSize":13616,"localTempSrc":"blob:https://www.yuque.com/0d8373e5-72f6-40e6-8ef2-9b80b01453ca","state":-2},"firstInsertRatio":0.8,"width":480,"height":167.88906009244994}},{"html":"​我们可以作如下更改以满足 bounded waiting：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b0d35063-32a7-4a08-b54e-3c40e2801d5c","children":[],"zIndex":188},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d3917f87-18bb-49b4-99bc-ead7280a6a23","children":[],"zIndex":187,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667572352479-4c2c774f-b115-4fe3-b2fd-918c6e111de0.png","naturalWidth":499,"naturalHeight":509,"uploadInfo":{"hash":"50a343af31b16459cbbbe98c87f3e74d459ed6eb05e56654f7edc1955e9e8eb1","fileName":"image.png","fileType":"image/png","fileSize":37142,"localTempSrc":"blob:https://www.yuque.com/efcc1e88-05bd-4f9d-8871-6aa2815e8b39","state":-2},"firstInsertRatio":0.8,"width":399.20000000000005,"height":407.20000000000005}},{"html":"​我们引入了 bool 数组 waiting[] 。在 Entry Section 中，我们首先置 waiting[i] 为 true；当 waiting[i] 或者 lock 中任意一个被释放时，进程可以进入 Critical Section。初始时， lock 为 false，第一个请求进入 CS 的进程可以获许运行。在 Exit Section 中，进程从下一个进程开始，遍历一遍所有进程，发现正在等待的进程时释放它的 waiting[j] ，使其获许进入 CS，当前进程继续 Remainder Section 的运行；如果没有任何进程在等待，那么它释放 lock ，使得之后第一个请求进入 CS 的进程可以直接获许。<div>这样的方式可以保证每一个进程至多等待 n-1 个进程在其前面进入 CS，满足了 bounded waiting 条件。</div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"95aaa670-7613-4570-bdcf-dc9cfa9a135e","children":[],"zIndex":186}],"zIndex":196,"collapsed":true},{"html":"​compare_and_swap","border":{"shape":"rect","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c2a64f2b-27b9-4550-b304-c97cc154e7a8","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7ce3c6c2-3cb5-4ef6-a49b-4e2c1812d95e","children":[],"zIndex":159,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667573899808-2403680b-64b1-4df1-a97a-8b0fed506cc9.png","naturalWidth":663,"naturalHeight":159,"uploadInfo":{"hash":"4f3d4d0d91b60ae010ba87d1555f4def02f34665558e2f2654e43ae9b5f6633d","fileName":"image.png","fileType":"image/png","fileSize":15023,"localTempSrc":"blob:https://www.yuque.com/220237e5-3b04-4c47-9f6f-5ea9e8025279","state":-2},"firstInsertRatio":0.8,"width":480,"height":115.11312217194569},"html":"<div style=\"text-align:center;\"><span style>​</span></div>"},{"html":"同样，compare_and_swap() 的执行是 atomic 的。类似地，我们声明一个全局变量 lock ，初始值设为 0。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e54f8b4a-e383-4975-966b-c4c72dec7b9d","children":[],"zIndex":158},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7078f8a2-1c4a-475a-8ee9-8756811ee13e","children":[],"zIndex":157,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667575145227-72d0751b-95b7-4798-8b86-2972ff487199.png","naturalWidth":515,"naturalHeight":309,"uploadInfo":{"hash":"1ebf87223950daa77a5ff2da8a2e5d2ade67b89da36b6eca7ae28d6e1d3c6b7c","fileName":"image.png","fileType":"image/png","fileSize":20780,"localTempSrc":"blob:https://www.yuque.com/3aaeb993-3a88-4c24-80d9-e6bead56bc16","state":-2},"firstInsertRatio":0.8,"width":412,"height":247.2}},{"html":"​可见，compare_and_swap() 和 test_and_set() 没有本质区别。上例 compare_and_swap()  的使用方法同样无法保证 bounded waiting，我们可以使用与 test_and_set() 同样的方式来解决。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f89ea0a2-7bdc-45ae-a451-aa6cf33343e8","children":[],"zIndex":156}],"zIndex":195,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"zIndex":238,"collapsed":true},{"html":"​Atomic Var","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1],"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"2ba363ef-d855-4572-84b9-796fc57ae80f","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6109e5b9-b788-4f73-a239-a4c8dd67ddce","children":[],"zIndex":202,"html":"​如我们先前所说，之前介绍的指令常被用来作为同步工具的组成部分而不是直接使用，我们可以使用 compare_and_swap() 指令来实现一些工具。其中一个工具就是 <span style=\"font-weight:bold;\">Atomic Variable</span>。"},{"html":"​一个变量在更新的过程中可能会导致一个 race condition。Atomic Variable 可以为数据提供 atomic updates。例如，我们使用不可打断的 increment(&amp;count); 指令来代替可被打断的 count++ 指令就可以解决本节开头的 Bounded-buffer Problem：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c2e8400a-933d-48a7-9801-ac334b68d60d","children":[],"zIndex":201},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"dfe6ea0b-85bf-40ea-ac81-6e8961702095","children":[],"zIndex":200,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667575474788-bd4c93ae-c25c-4f44-9eda-94a4b3cf216f.png","naturalWidth":605,"naturalHeight":164,"uploadInfo":{"hash":"bf761e63a84b3e8701c3cecc2ce008a718ef3ae24b6d90701217a9289d875dfa","fileName":"image.png","fileType":"image/png","fileSize":12961,"localTempSrc":"blob:https://www.yuque.com/ec284482-0eb6-45eb-8df4-73fe66f312ce","state":-2},"firstInsertRatio":0.8,"width":480,"height":130.11570247933884}},{"html":"​程序循环尝试将 v 赋值为 temp+1 ，当赋值成功时返回。由于 CAS 指令是 atomic 的，因此它不会在运行过程中被打断；在程序其他运行过程中 v 的值都没有发生改变。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d2d0ef33-2b1e-4edd-ae15-2d88bf0036c4","children":[],"zIndex":199},{"html":"​但是需要注意的是，如果 buffer 有两个 consumer 在同时等待读取，那么当 count 由 0 变成 1 的时候两个 consumer 可能会同时进入来读取，但是实际上只有 1 个值在 buffer 中。即，Atomic Variable 并不能解决所有 race condition，因为它解决的问题仅是变量更新过程中的 race condition。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"92ea6fbe-daf0-4ca9-aa96-6b5342119747","children":[],"zIndex":198}],"zIndex":237,"collapsed":true},{"html":"​Mutex","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3cd6f330-8e48-4bac-9b3d-2c707c492fc5","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8f79b1c1-a0c1-43cf-abe3-0afed700471a","children":[],"zIndex":214,"html":"​我们尝试设计软件工具来解决 CS problem。我们讨论 Mutex (MUTual EXclusion) Lock 的实现，它通常被认为是最简单的 synchronization tool。"},{"html":"​我们考虑让进程在 Entry Section 申请 acquire() 一个锁，然后在 Exit Section release() 一个锁。对于这个锁，我们用一个布尔变量来表示它是否 avaliable ：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5fc910ab-ce00-47d9-b137-33e44300e62f","children":[],"zIndex":213},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0516ea24-7d07-4d3a-b041-293d28071362","children":[],"zIndex":212,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667575764138-6ec54073-7138-49e4-8b5d-3d97beaa633c.png","naturalWidth":353,"naturalHeight":438,"uploadInfo":{"hash":"4918f01fb10735b542b5dca8bd094f65e8d4443a03048957fd75b0de5ba53846","fileName":"image.png","fileType":"image/png","fileSize":26039,"localTempSrc":"blob:https://www.yuque.com/d2f4a01f-495f-453b-8351-c7e4ec3c1a56","state":-2},"firstInsertRatio":0.8,"width":282.40000000000003,"height":350.40000000000003}},{"html":"​我们需要保证 acquire() 和 release() 是 atomic 的。我们可以使用 test_and_set() 和 compare_and_swap() 来实现：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a667bf63-6edd-4f12-90d1-9ec22457dd3d","children":[],"zIndex":211},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"00bf2ef8-a60b-476c-a836-f0a6495ad57f","children":[],"zIndex":210,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667575793895-04323d1c-0f62-4d15-8039-169b32f102ce.png","naturalWidth":565,"naturalHeight":214,"uploadInfo":{"hash":"e028b6093635f2af9c836aa33bd59ba1b10aba782ab377c3ac26de62f55f4bd2","fileName":"image.png","fileType":"image/png","fileSize":15301,"localTempSrc":"blob:https://www.yuque.com/e4636538-6ac1-42d6-a463-cf5dbb2dec16","state":-2},"firstInsertRatio":0.8,"width":452,"height":171.20000000000002}},{"html":"​但是这种实现的缺点是，它需要 <span style=\"font-weight:bold;\">busy waiting</span>，即当有一个进程在临界区中时，其他进程在请求进入临界区时会在 acquire() 中持续等待。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cc2a4466-e58a-4c9e-996c-9281b2d38d77","children":[],"zIndex":209},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8b2286be-dc54-4912-84d7-e8b350268837","children":[],"zIndex":208,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667576069283-693590ab-b85a-4b9b-b6c9-5def0fbbb066.png","naturalWidth":940,"naturalHeight":135,"uploadInfo":{"hash":"a7086d5920b6c418b3b478747fe7d85c1fbf9f9f9e34bbcbadbbbba08fc68df9","fileName":"image.png","fileType":"image/png","fileSize":13696,"localTempSrc":"blob:https://www.yuque.com/5d96dd0e-c030-41ff-a2e4-d87160d6f567","state":-2},"firstInsertRatio":0.8,"width":634.337278451495,"height":91.1016304159062},"width":650.337278451495,"height":165.6194029850741},{"html":"​可以发现，T1 在它的 CPU 时间内不断循环等待，直到 T0 释放锁。因此这种锁也成为 <span style=\"font-weight:bold;\">spinlock</span>。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8d4d46aa-20e8-482b-ad30-db6036af8495","children":[],"zIndex":207},{"html":"​可以想象，如果有 N 个进程同时使用一个 CPU，那么将有大约 (N-1)/N 的时间被浪费。如果有进程在企图 acquire 一个锁时被阻止，我们称它是&nbsp;<span style=\"font-weight:bold;\">contended</span>（被争夺）；反之我们称它 uncontended。如我们所述，highly contended locks 会降低当前运行程序的整体性能。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"21b015f8-5294-4fd7-8f11-7e766f6db56e","children":[],"zIndex":206},{"html":"​我们还可以考虑下面的设计，其中 yield() 会使程序从 running 转为 ready，从而让出 CPU：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"58d3ef8a-8d59-4e7c-a1cc-106bbf0c2601","children":[],"zIndex":205},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6cc318b7-aedf-4fce-b715-0c4592c5a446","children":[],"zIndex":204,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667577074009-1acd4275-ef6b-48a6-849b-016a16ba0e63.png","naturalWidth":553,"naturalHeight":209,"uploadInfo":{"hash":"3b48a00e1113f52d2b9b74079f3f4d81b2c5e89b55933242d41ae5337ad98e43","fileName":"image.png","fileType":"image/png","fileSize":14335,"localTempSrc":"blob:https://www.yuque.com/8e6a3581-e253-4530-82d3-804af0622bec","state":-2},"firstInsertRatio":0.8,"width":442.40000000000003,"height":167.20000000000002}},{"html":"​不过，如果所需的等待时间一般小于 context switch 所需的时间的话，用 spinlock 可能是更好的。(<a href=\"https://gateoverflow.in/227185/process-synchronization\" target=\"_blank\" style>Ref</a>)","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"bd2e3cca-e159-4c33-ba48-d327cfe12158","children":[],"layout":{"quadrant":1},"zIndex":203}],"zIndex":236,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Semaphores","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1e9775fc-09c1-4652-8b04-a65b67cc941a","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"715e843e-5149-4d91-a82f-4be4e3175dfa","children":[],"zIndex":222,"html":"​我们给出一种更厉害的 synchronization tool，称为 semaphore。一个 semaphore S 是一个整型变量，它除了初始化外只能通过两个 atomic 操作 wait() 和 signal() （原称为 P() 和 V() ）来访问："},{"html":"<div style=\"text-align:center;\"><span style>​需要重申的是， wait() 和 signal() 应该是 atomic 的。</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"933e4f41-7ea9-4461-8406-a113a39b3607","children":[],"zIndex":221,"height":226.92312849813462,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667577831020-7f1bb628-511f-4767-a9ca-41093591dbf9.png","naturalWidth":357,"naturalHeight":237,"uploadInfo":{"hash":"785ec503fc78223c99f8758c769b01826f558fa841d7b1b4b9065d07ddf372ca","fileName":"image.png","fileType":"image/png","fileSize":11957,"localTempSrc":"blob:https://www.yuque.com/744437db-8039-46ca-8893-8940dc3ff511","state":-2},"firstInsertRatio":0.8,"width":292.11205431997496,"height":193.92312849813462},"width":492.39254897388264},{"html":"​有 2 种 semaphore：<div>● Counting semaphore - S 的值不受限制；</div><div>● Binary semaphore - S 的值只能是 0 或 1。类似于互斥锁。</div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cfc5af9b-7acf-47bd-a8e9-2c9907cab946","children":[],"zIndex":220},{"html":"<div style=\"text-align:center;\"><span style>一个例子</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e04cc70e-b842-49f9-9f92-6453cb42b637","children":[],"zIndex":219,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667577902499-6e90f5dd-1150-49bf-9254-e8cacd325516.png","naturalWidth":659,"naturalHeight":310,"uploadInfo":{"hash":"2470ea14d775634ca4cac47fbab04f2a77015d16f0175c515706f15c1055a7da","fileName":"image.png","fileType":"image/png","fileSize":26169,"localTempSrc":"blob:https://www.yuque.com/5ff9c74c-67c0-4b50-ba85-fc514bf4cfa6","state":-2},"firstInsertRatio":0.8,"width":480,"height":225.79666160849771}},{"html":"​但是，如同前面我们所说，semaphore 也具有 busy waiting 的问题。为了解决这个问题，我们可以为 semaphore 引入 waiting queue：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2dcbeec8-572b-42c8-a849-0bad2f53152e","children":[],"zIndex":218},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a61ba5f2-4efd-4e4c-9ddb-e85fd93adfb0","children":[],"zIndex":217,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667579586789-5022367d-f68e-4340-a5ce-3feb694a4da8.png","naturalWidth":448,"naturalHeight":491,"uploadInfo":{"hash":"daa4584ec1d5932d2cf8f5ab012970a4c8a79d5a9c777fc6473a3fdc6d11bb12","fileName":"image.png","fileType":"image/png","fileSize":34345,"localTempSrc":"blob:https://www.yuque.com/ee002d7f-28c5-4375-8b18-ae7567f81a6c","state":-2},"firstInsertRatio":0.8,"width":358.40000000000003,"height":392.8}},{"html":"​但是，semaphore 可能会导致 deadlock：","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a7279f88-3b51-4621-911f-5884fce9f90c","children":[],"zIndex":216},{"html":"<div style=\"text-align:center;\"><span style>​</span></div>","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0003829b-2fba-4592-a044-e3461897ad18","children":[],"zIndex":215,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667579781970-db70a6f5-4801-4a81-9978-a0baa5fc93e0.png","naturalWidth":814,"naturalHeight":377,"uploadInfo":{"hash":"05498a2bcd9a88832205700f59a9a34bc8a2d8a4c88f67ea4ea3169964ca4046","fileName":"image.png","fileType":"image/png","fileSize":47724,"localTempSrc":"blob:https://www.yuque.com/0aa47ad0-0910-4c6a-bdb4-43a8846c4d80","state":-2},"firstInsertRatio":0.8,"width":480,"height":222.30958230958228}}],"zIndex":235,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true},{"html":"​Priority Inversion","border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0257fa3f-1168-4776-81b0-447120deae7e","children":[{"border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"437349eb-437f-45a2-b444-998a53bd499a","children":[],"zIndex":225,"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1667571678976-ad83d541-072c-43b8-a42f-f54687792195.png","naturalWidth":785,"naturalHeight":268,"uploadInfo":{"hash":"7315fc30d5d1957baf4d1fbe26a088c3ae64b17bdad3f62e1afa328b79c014b9","fileName":"image.png","fileType":"image/png","fileSize":34236,"localTempSrc":"blob:https://www.yuque.com/45dc2dc6-b1f3-4047-88b6-552b583c3942","state":-2},"firstInsertRatio":0.8,"width":480,"height":163.87261146496814},"html":"<div style=\"text-align:center;\"><span style>​</span></div>"},{"html":"​这个问题称为 <span style=\"font-weight:bold;\">priority inversion</span>，即具有中等优先级的 M 的运行时间反而影响了具有较高优先级的 H 的等待时间。","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2033a110-7c7c-4d43-8280-233757585e03","children":[],"zIndex":224},{"html":"​我们可以通过优先级继承 <span style=\"font-weight:bold;\">priority inheritance</span> 来解决这一问题：所有正在访问资源（如上例中，低优先级的 L 所持的锁）的进程获得需要访问这个资源的更高优先级进程的优先级，直到它们用完有关资源为止。（如上例中，priority inheritance 将允许 L 临时继承 H 的优先级从而防止被 M 抢占；当 L 释放锁后则回到原来的优先级，此时 H 将在 M 之前执行。）","border":{"shape":"line","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"30597b5b-9bb6-4602-89dc-ee777a790b56","children":[],"zIndex":223}],"zIndex":234,"layout":{"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"collapsed":true}],"html":"Sync Tools​","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1],"quadrant":1},"icons":{"progress":6},"zIndex":243,"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1],"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"d19851ee-288a-4b7d-b0af-adef32f3f29f","children":[],"zIndex":242,"html":"​Sync Examples","icons":{"progress":0}}],"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"layout":{"quadrant":1},"zIndex":245,"collapsed":true},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"00b4e7a2-2ce8-4958-8cbb-ee496ec5fb57","children":[],"zIndex":244,"html":"死锁","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"icons":{"progress":0}}],"zIndex":253,"icons":{"progress":2},"collapsed":true},{"html":"Memory Management","layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#DFB85D"},"id":"f6e7e509-df56-4076-8029-1cb5c6f912d2","children":[{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"a751d9bc-f425-4572-9a25-984fe675b933","children":[],"zIndex":137,"html":"主存","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"icons":{"progress":0}},{"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"id":"02bf0938-5dd8-4335-883f-9399e9d0425e","children":[],"zIndex":136,"html":"虚拟内存","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"icons":{"progress":0}}],"zIndex":252,"icons":{"progress":0},"collapsed":true},{"html":"Storage Management","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#B1C774"},"id":"741b11e2-3906-4424-9c69-3dc4b4a32236","children":[],"zIndex":250,"icons":{"progress":0}},{"html":"File System","layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"capsule","fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#77C386"},"id":"82a3df7b-49be-4385-97d9-11a5380ed0b6","children":[],"zIndex":248,"icons":{"progress":0}},{"border":{"shape":"rect"},"layout":{"type":"timeline","direction":[1,0],"quadrantConstraint":[1],"quadrant":2},"treeEdge":{"stroke":"#C28976"},"id":"28860df9-c270-4ad3-9481-32911771126d","children":[{"border":{"shape":"line"},"id":"d8fc3e91-c16f-4866-b494-8c1097001c0e","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2022/png/641515/1666337791543-895bcfb6-e68e-4044-a88f-3b710e790b52.png","naturalWidth":718,"naturalHeight":345,"uploadInfo":{"hash":"b085acb98652d5e96fac93592fad1a12a3da8273514bd0f053ce384da45c0a59","fileName":"image.png","fileType":"image/png","fileSize":53268,"localTempSrc":"blob:https://www.yuque.com/351c34ca-3c77-4d57-a367-702474752968","state":-2},"firstInsertRatio":0.4,"width":453.2598911362806,"height":217.79200897216828},"width":506.8559820556644,"height":225.79200897216828,"html":"<div style=\"text-align:center;\"><span style></span></div>","layout":{"type":"standard","quadrant":1},"defaultContentStyle":{"color":"rgb(38, 38, 38)"},"zIndex":246}],"zIndex":247,"html":"常用的图！"}],"tapered":true,"layout":{"type":"standard","direction":[1,0]}}]},"mode":"edit","viewportSetting":{"zoom":1.0468749999999991,"tlCanvasPoint":[-34.707464872900495,105.9925309366253,1],"width":1152,"height":508},"viewportOption":"adapt","text":"操作系统Overview操作系统是啥我们现在搞好了一个 CPU，还有配套的内存之类的设备，现在要用它。可以直接把汇编写到内存里运行。计算机最开始是为了研究可计算性理论的，但很快就被用于一些专用的计算，例如破译密码等；随后演化出了 general-purpose, multifunction mainframes如果有很多程序要一个一个运行，怎么办呢？写一个一直运行的程序 (kernel)，负责其他程序的运行。批处理系统, Batch Processing Systems。Jobs 在内存或者外存里，内存始终有一个 job 在运行，操作系统负责在结束后加载下一个开始运行（我们将加载到内存并运行的程序为 进程, process）。问题在于如果运行时发生 I/O，CPU 就会停下来等 I/O 完成。多道批处理系统, Multiprogramming Batch Systems。在批处理系统基础上，当当前 job 发生 I/O 时，操作系统负责让 CPU 转而运行另一个 job。问题在于，没有考虑和用户的交互，响应时间较长。分时系统, Time Sharing Systems。将 CPU 时间划分为很小的时间片，操作系统负责安排各个 job 轮流运行。由于切换频率很高，从而用户通过输入设备向计算机发出指令时可以收到实时的回复。分时系统本身也是一种多道 (multiprogramming) 系统，即允许多个 job 并发 (concurrently) 执行。但是不是批处理 (batch) 系统。除了 kernel 外，操作系统还包含一些 system programs，辅助 kernel 工作。其他程序不属于操作系统，称为 application programs。总结来说，操作系统是“软件中最基础的部分”，用以控制和管理系统资源、方便用户使用计算机。中断 | Interrupt批处理系统的实现是容易理解的；每个程序就像是一个函数一样被操作系统调用。那么其他类型的操作系统是如何实现在程序运行时能够收回控制权呢？这就需要使用到 中断 (interrupt)。现代操作系统都是 中断驱动 (interrupt driven) 的。事件发生通常通过硬件或软件的中断通知。CPU 硬件有一条称为 interrupt-request line 的线路，CPU 在执行每一条指令后都要检测它一次。当 CPU 侦测到一个设备控制器在这条线路上发出的信号时，会读取 interrupt number 并且以此作为 interrupt vector 中的 index 来跳转到对应的 interrupt-handler routine。中断向量表 (interrupt vector) 用来减少确定中断服务时的查找次数，即通过随机访问而不是遍历的方式找到处理程序。在现在的操作系统上，我们还需要一些更复杂的中断处理功能：1. 我们需要能够在关键程序处理期间延迟中断的处理；2. 我们需要一种高效的方法来将设备中断发给正确的中断处理程序；3. 我们需要多级中断，从而使得操作系统可以区分不同优先级的中断并根据适当的紧急程度进行响应。在现代的计算机硬件中，这些特性由 CPU 和 interrupt-controller hardware 实现。大多数 CPU 有两条 interrupt-request line，一条用于 nonmaskable interrupt，为一些不可恢复的内存错误等事件保留；另一条是 maskable 的，它可以在执行不可中断的关键程序之前被 CPU 关闭，用于传送一些设备控制器的中断请求。我们都知道，在调用函数时需要保存 PC 等现场状态；执行中断时也需要保存。但是，值得注意的是，虽然低级的中断可以被高级的中断打断，但是保存和恢复现场状态的过程是不能被打断的。当操作系统将 CPU 的控制权交给一个程序前，会设定好一个 计时器 (timer)。计时器通过一个时钟和一个计数器实现。当计数器的值为 0 时，就会产生一个中断，这时控制权就交给了操作系统。这种方式可以防止程序执行时间过长，也可以用来实现分时系统。Dual-mode & Multimode操作系统和用户共享计算机的软件和硬件。因此，一个错误的程序可能会导致整个系统崩溃，或者使得其他用户的数据甚至操作系统本身被修改。因此，操作系统的设计要保证一个错误的程序不会造成其他程序的错误运行。我们将操作系统代码和用户代码区分执行。出于安全考虑，用户代码不能直接执行部分可能引起损害的指令；我们称这些指令为 privileged instructions。CPU 硬件有一个 mode bit，值为 0 表示当前处于 kernel mode (或称为 supervisor mode, system mode, privileged mode)；值为 1 表示当前处于 user mode，此时 CPU 将会把所有 privileged inst. 视为非法指令。所有的 interrupt handler 都运行在 kernel mode那如果用户程序确实想做这些事情怎么办呢？它们可以通过 system call 的方式向操作系统提出请求，由操作系统代为完成。也有可能有更多 mode，或者叫 privilege level。例如在虚拟化的情境下，可能会支持多于 user mode 但是少于 kernel mode 的指令等。因此，当发生中断、system call、错误（例如除以 0，或者访问未知指令）等情况时，会发生 user mode 到 kernel mode 的转换。System Calls系统调用可能需要传递参数。参数可以放在寄存器里直接传递；也可以放在一块内存中，用寄存器传递地址；也可以用栈传递。Process Management进程进程是啥进程 (Process) 是被加载到内存中、正在运行的程序。多个进程可能对应同一个程序。一个正在运行的 OS 中会有多个进程。进程是程序的一次执行过程，是操作系统分配资源的基本单位。由于历史原因，进程 process 和 作业 job 这两个概念可以认为是等同的。一个进程包括……code (text)，即程序代码，加载到内存前以 executable file 的形式存储在 disk 中program counter，指向下一个要运行的指令content of the processer's registers runtime stack，由用户代码操控（编译时完成关于栈的相关调用），在调用函数时暂时存储一些数据，如 local variables, return address, return values, state of registers, parameters 等。其中的条目称为 activation records (stack frames)data section，存 static variablesheap，动态分配的内存Executable and Linkable Format.data: 初始化了的静态变量.bss: block starting symbol，未初始化的静态变量。ELF 里只会存这个段的长度，加载到内存时会占用对应大小的空间，初值为 0一个进程可能处于……一个处理器上，只有一个进程可以 running，更多的进程可能处于 ready 或 waiting 状态操作系统用 Process Control Block (PCB, a.k.a. task control block) 表示进程，每个进程有且仅有一个 PCB。PCB 包含许多当前进程的相关信息，如……CPU registers，存储所有进程相关的寄存器的值CPU scheduling information，properities, scheduling queue pointers, etc.Memory-management information，基地址、页表之类的Accounting information，CPU 使用时间、时间限制等I/O status information，分配给进程的 I/O 设备列表、打开文件列表等不同的系统可能有不同的 PCB。Linux 中的进程用结构体 task_struct 存储。进程的创建大多数操作系统通过一个唯一的 进程标识符 (process indentifier, pid) 来标识一个进程。一个进程在运行时可以创建新的进程，则它成为父进程，新建进程称为子进程；父进程的 pid 称为子进程的 ppid (parent's pid) 。这样进程会成为一个 进程树 (process tree) 传统的 UNIX 系统用进程 init (a.k.a System V init , 它的 pid 总是 1) 作为所有用户进程的根进程。系统启动后，进程 init 可以创建各种用户进程。在最近的 Linux 版本中， init 被 systemd 替换了。 systemd 功能类似 init ，但提供了更多服务。当子进程被创建时，它会需要一定的资源（CPU 时间、内存、文件、I/O 设备等）来完成任务。它可以从操作系统那里直接获取资源，也可以从父进程那里继承（共享）一些资源。建立子进程时，父进程也可以向子进程传递一些初始化数据，例如父进程创建一个显示图片的子进程时，可以将该图片的路径或文件名等传递给子进程。UNIX 系统中可以使用系统调用 fork() 来创建一个新进程。这个新进程是父进程的一份拷贝，它们只有 pid 和 ppid 不同，另外子进程当前内存使用记录为 0，除此以外全部相同。 fork() 对父进程返回该子进程的 pid，而对子进程返回 0。fork()  如何对父进程和子进程返回不同的值？一种实现方式是，在进入 fork() 时存下当前的 pid，在建立新进程后（此时存下子进程的 pid），父进程和子进程都将分别完成 fork() 剩余代码的执行。在进行返回时， fork() 检查当前的 pid 与前面存下的是否一致，如果一致则说明当前是父进程，返回子进程的 pid；不一致则说明是子进程，返回 0。也就是说，当进程创建新进程时，父进程可以  ○ 继续运行（和子进程并发执行，即同时或者交替运行），或者  ○ 等待子进程运行完后再运行子进程的地址空间有可能  ○ 使用父进程的一份拷贝，或者  ○ 加载另一个新的程序为什么要拷贝一份呢？考虑这样的代码：https://godbolt.org/z/78a8sTKhP，子进程虽然和父进程跑的是一样的代码，但是不应当使用同一份数据。聪明的小朋友可能会问了，上面这种代码，child 将当前地址空间拷贝一份岂不是很浪费吗？因为根本没有用到。确实如此，因此部分 UNIX 的实现引入了 copy-on-write 机制，将地址空间的复制推迟到需要写入的时候再进行。UNIX 对启动新进程的逻辑是简单的。fork 的意义就是制造当前进程的一个副本，而 exec 的意义是用一个新的程序替代当前的进程。（Link）系统调用 getpid() 和 getppid() 可以分别获取进程的 pid 和 ppid。进程的终止系统调用 exit() 会使得进程终止。C 语言 main 函数返回时也会隐式地调用 exit()。除此之外，进程也会由于一些信号、异常等终止。前面的代码中展示了 wait() 的系统调用，它使得当前进程进入 waiting 状态，并在任一子进程终止，或被信号停止，或被信号恢复时进入 ready 状态，同时返回发生该事件的子进程的 pid。当一个进程终止时，它进入 terminated 状态，它的资源被操作系统回收。但是，操作系统仍然会保存一些信息（例如 PID，结束状态，资源使用情况等 Ref），因为父进程有可能会需要调用 wait() 来获取其一些信息。当子进程已经终止，但父进程在忙，还没有调用 wait()，我们称这样的子进程为 僵尸进程 (zombie processes)，因为前述信息仍然占据了进程表中的一项；如果表满了，就不能创建新的进程了。当子进程没有结束，或者终止了但父进程没有调用 wait() 的情况下，父进程就结束了，子进程就会成为 孤儿进程 (orphan processes)。一些操作系统会将孤儿进程一同终止掉，但是 UNIX 的做法是让 init 进程收养它们，即 init 进程成为其父进程。init 进程会定期调用 wait()，从而收集孤儿进程的退出状态，并释放进程表条目。所以，如果我们想创建一个 守护进程 (daemon，在后台运行的、生存期长的进程，例如 host 一项服务等)，我们可以 fork 两次，让 grandchild 执行对应任务，而 child 直接终止，这样 grandchild 就会成为孤儿从而被 init 收养。进程间通信进程间通信 (IPC, InterProcess Communication) 是为了在进程的资源相互隔离的情况下，让不同的进程能相互访问资源从而协调工作。​主要有两种方式：共享内存 (shared memory) 和 消息传递 (message passing)。信号量 (semaphores) 本意用来线程间同步，但是可以通过 sem_open() 系统调用来建立和维护进程间的信号量；这样的信号量属于 OS 资源，它会在相关进程结束后由 OS 释放 (Ref1, Ref2)共享内存 的实现是，两个进程各自有一块虚拟内存，映射到同一块物理内存。共享内存也需要信号量等同步手段保护。​共享文件。​管道 (pipe)。管道的实现其实也是文件，创建管道时操作系统会返回两端的文件描述符；逻辑上实现的是一个半双工的信道。​消息队列 (message queue)。为什么需要消息队列呢？共享文件显然很慢，而共享内存比较难适用信息大小不等、信息读一次就失效等场景，且共享内存需要同步手段。消息队列可以解决这些问题。消息队列，其实就是操作系统维护的一个一个的链表，进程可以新建或者连接到一个消息队列，并写入消息，或读取第一条满足一定条件的消息。(Ref1, Ref2)​Socket。TCP / UDP，适用于双方不一定在同一个计算机上的情况。调度​CPU 调度是啥​多道 (multiprogramming) 环境下，进程的个数通常大于 CPU 的个数。CPU 调度就是 OS 关于哪个 ready 进程可以运行（使用 CPU）以及运行多久的决定。​其目标是始终允许某个进程运行以最大化 CPU 利用率，同时保证一定的公平性。这在多道环境下是必要的，关系到系统的整体效率。​调度的时机​​​CPU 调度可能出现在某一个进程：\n  a. Running -> Waiting，如等待 I/O\n  b. Running -> Terminated   c. Running -> Ready，当发生了 interrupt，如计时器到时间了\n  d. Waiting -> Ready，如 I/O 完成了  e. New -> Ready​非抢占式 (nonpreemptive) 调度只会在 a, b 处进行调度，因为只有这时候当前正在运行的进程不能再运行了；抢占式 (preemptive) 调度会发生在上述任何时机。因此，抢占式调度使得 OS 有更充分的控制，但它也更复杂。​也就是说，当上述情况发生时，可以直接调用调度器来进行调度。​调度的过程​​这个过程叫 上下文切换 (context switch)，这里的上下文其实就由 PCB 来表示。​调度算法的评价对于不同的应用场景，我们对 scheduling 的要求也有所不同，有些也会有冲突。为此，我们需要充分考虑各种算法的属性。我们可能需要的要求包括：Maximize CPU Utilization : CPU 使用率，即 CPU 非空闲的时间比例Maximize Throughput : 吞吐量，每个时间单元内完成的进程Minimize Turnaround Time : 周转时间，从进程创立到进程完成的时间，包括等待进入内存、在 ready queue 中等待、在 CPU 上执行、I/O 执行等时间Minimize Waiting Time : 等待时间，在 ready queue 中（或在 Ready 状态下）等待所花的时间之和Minimize Response Time : 响应时间，交互系统从进程创立到第一次产生响应的时间​这些要求有时甚至是冲突的。例如，较多的 context switch 会减少 throughput，因为 context switch 过程中并没有有用的工作；而较少的 context switch 会增加 response time。​调度算法​First-Come First-Served (FCFS) | Nonpreemptive​先申请 CPU 的进程首先获得 CPU。可以用一个 FIFO 队列简单实现。​​Convoy effect - short process behind long process​尤其是当有进程进入 waiting 后，再返回的时候又需要重新排队​Shortest-Job-First (SJF)​Non-preemptive: Shortest-next-CPU-burst​每当 CPU 调度时，其选取 ready queue 中下次 CPU 执行时间最短的进程。这样会使得给定的一组进程具有 minimum average waiting time.​​Preemptive: Shortest-remaining-time-first​每当 CPU 调度时（注意抢占式调度的调度时机），选择最短剩余运行时间的进程。​​SJF 可以获得最小的平均等待时间，但最大的问题在于我们并不知道剩余的运行时间。解决方案是预测，将下次执行时间预测为此前 CPU 执行长度的指数平均。​Round-Robin (RR) | Preemptive​定义一个 时间片 (time slice / time quantum) ，即一个固定的较小时间单元 (10-100ms)。除非一个 process 是 ready queue 中的唯一进程，它不会连续运行超过一个时间片的时间。Ready queue 是一个 FIFO 的循环队列。每次调度时取出 ready queue 中的第一个进程，设置一个计时器使得进程在一个时间片后发生中断，然后 dispatch the process。​​相比 SJF 而言，平均等待时间更长，但响应时间更短。​RR scheduling 的性能很大程度上取决于时间片的大小。如果时间片较小，则 response/interactivity 会很好，但会有较大的 overhead，因为有较多的 context-switch；时间片较大则响应较差，但 overhead 会较小。如果时间片 -> INF，则 RR -> FCFS。​在实践中，时间片大约 10~100ms，每次 contest-switch 约 10μs。即 context-switch 的时间花费是比较小的。​Priority Scheduling​每个进程都有一个优先级，每次调度时选取最高优先级的进程。（下例中规定优先级值小的优先级高。）​​优先级可以是内部的或者外部的：internal: 一些测量数据，例如 SJF 是 Priority 的一个特例，即优先级由预测 CPU 运行时间决定。external: 由用户指定进程的重要性。​Priority Scheduling 也可以与 Round-Robin 结合，如：​​要实现 Priority Scheduling，可以简单地将 ready queue 用 priority queue 实现；priority queue 也可以是抢占式或非抢占式的，如 SJF 一样。​Priority 的一个重要问题是 indefinite blocking / starvation ，即低优先级的进程可能永远没有机会被执行。一个解决方法是 Priority Aging ，即根据等待时间逐渐增加在系统中等待的进程的优先级。​Multilevel Queue Scheduling​在实际应用中，进程通常被分为不同的组，每个组有一个自己的 ready queue，且每个队列内部有自己独立的调度算法。例如，前台队列使用 RR 调度以保证 response，后台队列可以使用 FCFS。同时，队列之间也应当有调度。通常使用 preemptive priority scheduling，即当且仅当高优先级的队列（如前台队列）为空时，低优先级的队列（如后台队列）中的进程才能获准运行。也可以使用队列间的 time-slicing，例如一个队列使用 80% 的时间片而另一个使用 20%。例如：​​Multilevel Feedback Queue Scheduling​Multilevel Feedback Queue Scheduling 允许进程在队列之间迁移。这种算法可以有很多种实现，因为队列的数量、每个队列中的调度策略、队列之间的调度算法以及将进程升级到更高优先级/降级到更低优先级的队列的条件都是可变的。一个系统中的最优配置在另一个系统中不一定很好。这种算法也是最为复杂的。​看这样一个例子：有三个队列 0, 1, 2，优先级逐次降低。当进程 ready 时被添加到 Q0 中，Q0 内部采用 RR Scheduling，的每个进程都有 8ms 的时间完成其运行，如果没有完成则被打断并进入 Q1；只有当 Q0 为空时 Q1 才可能被运行。Q1 内部也使用 RR Scheduling，每个进程有 16ms 时间完成其运行，如果没有完成则被打断并进入 Q2；只有当 Q1 也为空时 Q2 才可能被运行。Q2 内部采用 FCFS 算法。​线程​为什么要有线程在进程一节中，我们看到了进程在 fork 时有较大的开销，也看到了 copy-on-write 等技术能够减少这些开销；在调度一节中，我们同样看到了上下文切换时会带来的开销。我们容易意识到，在很多情况下，若干进程可能共享一些内容，而操作系统本身如果知道这些共享，则可以减省新建进程的开销以及进程间切换的时延。因此操作系统引入了 线程 (threads)。​在 Linux 中，线程也被称为 轻量级进程 (LightWeight Process)，这实际上是对线程非常恰当的一个描述。每个线程都有它自己的 thread ID, PC, register set 和 runtime stack。线程与同一进程的其他线程共享 code section, data section, heap, open files 以及 signals。​​​对于支持线程的操作系统，实际调度的是内核级线程而非进程。也就是说，线程是运行以及 CPU 调度的基本单元。（而进程是分配资源的基本单元。）​线程的优点​Economy: 建立线程相比进程是很经济的，因为 code, data & heap 已经在内存中了；另外在同一进程的线程间进行 context switch 时也会更快，因为我们不需要 cache flush。​Resource Sharing: 同一进程的线程之间天然共享内存，因此我们无需为它们编写 IPC；这也允许我们对同一块内存做并行的处理。但这也会引入风险。Responsiveness: 多线程的进程会有更好的响应性，即当一个线程 blocked 或者在做一些长时间的操作时，其他线程仍然能完成工作，包括对用户的响应。例如，在一个 client-server 结构中，我们用一个线程来响应客户端的请求。​Scalability: 在多处理器的体系结构中，多线程进程可以更好地发挥作用，因为每个线程都可以在一个处理器上运行；而单线程进程只能在一个处理器上运行。实际上，后两点对多个单线程进程也是适用的。但多线程进程相较而言更加经济和自然。​线程的缺点如果一个线程出现错误，那么整个进程都会去世（比如浏览器的一个网页挂了，那么可能整个浏览器都会挂）。由于 OS 对每个进程地址空间的大小限制，多线程可能会使得进程的内存限制更加紧缩（这在 64 位体系结构中不再是问题）。由于多个线程共享部分内存，因此内存保护会比较困难。线程的实现方式​​线程实现的重点是共享一些资源；而具体的实现分为 用户级线程 (User-Level Thread) 和 内核级线程 (Kernel-Level Thread) 两类。用户级线程的特点是，它在操作系统上只是一个进程，这个进程包含 线程库 (Thread Library) 的部分，​这部分代码负责完成线程的创建、切换等操作；而内核级线程则是由操作系统支持这些操作。​用户级线程的优点包括：​它并不实际占用操作系统的 TID (Thread ID) 等资源，因此理论上来说可以支持比内核级线程更多的线程数；​它的调度等操作代码均在用户态，不需要进入内核态；​比较容易实现自定义的调度算法。​用户级线程的缺点包括：一旦当前正在运行的线程阻塞，那么在操作系统看来就是整个进程被阻塞了，那么同一个进程中的其他线程也同样会被阻塞；而如果是内核级线程的话，一个线程阻塞了，其他线程仍然能正常运行。同一个进程中的多个用户级线程无法在多核上分别运行。​多线程模型​在同时支持用户级线程和内核级线程的系统中，用户级线程到内核级线程的映射方式有多种选择。​​这种方式其实和只支持用户级线程没啥区别​这种方式和只支持内核级线程也没啥区别​​​前面两种的组合，在这种情况下，n 个用户级线程可以映射到 m (<= n) 个内核级线程上。​Linux 线程​Linux 中没有特别区分进程和线程，它们都被称为 tasks，每一个线程都有一个 task_struct。（虽然从概念上说，线程应该都使用其所属进程的 PCB，但是 Linux 不是这么实现的！）​Linux 中可以通过 clone() 新建一个线程；这个系统调用包含了一大堆选项，包括新建的是一个线程还是进程，以及继承 / 新建哪些资源等。事实上，在很多实现中，fork() 的内部就是调用 clone() 实现的。​从用户视角而言，Linux 中的线程通过 TID (Thread ID) 标识，而来自同一个进程的多个线程应当具有同样的 PID (Process ID)；系统调用 gettid() 和 getpid() 的实现和这个理解是一样的。​但是事实上，task_struct 里面并没有 tid 这个字段，而是有 pid 和 tgid (Thread Group ID) 这两个字段。其实，这里的 pid 和我们前述的 TID 含义一致，而这里的 tgid 和前述 PID 含义一致。这主要是历史原因，在还不支持线程的年代，pid 作为调度的依据被使用；在支持多线程后，调度的单元从进程变为了线程，如果引入一个新的字段 tid，则需要修改相关的代码，因此 pid 被保留，但发挥 tid 的作用；引入了一个新的字段 tgid，表示这一组线程的标识符，也就是其所属进程的标识符。​Src​正因如此，从 Linux 2.4 开始，getpid() 返回的就不再是 pid 了，而是 tgid。(Ref, 参见 CLONE_THREAD 一节)​使用 ps 指令，还能看到一个名叫 LWP (LightWeight Process) 的值，这个值始终和 TID 的值相同；LWP 通常被用作给用户呈现，而 TID 更经常被用作 gettid() 之类的系统调用。还有一个字段叫 NLWP，表示进程中的线程个数。(Ref)Process Synchronization​同步Sync Tools​​为什么需要同步​我们说 Cooperating Process 是可以影响系统中其他进程或被其他进程影响的进程。​Cooperating processes 会共同使用一些数据，可能是直接使用同一段地址空间（代码+数据），或者是通过共享的内存或信息传递来共用一些数据。对数据的并发访问 (concurrent access) 可能会导致 data inconsistency，因为数据的一致性需要 cooperating processes 有序的运行。​​​一种可能的运行顺序​出现这个问题，是因为我们允许两个进程同时操控变量 count 。类似这样的多个进程同时操控同一个数据，因而结果取决于每一种操控的出现顺序的情形，称为 race condition。为了防止 race condition，我们需要保证同一时间只有一个进程可以操控某个变量。​Race condition 在操作系统中是常见的。Kernel code 中也包含 race condition 的可能性。​​两个进程 P0 和 P1 同时 fork() 时，如果不加限制，可能会出现类似前例的情况，即在某一个进程把当前的 next_avaliable_pid 分配给他的 child 后，在没来得及更新 next_avaliable_pid 前，另一个进程使用了 next_avaliable_pid 来给 child 分配 PID，这就会导致两个不同的线程使用同一个 PID 的情况。​问题建模​考虑一个有 n 个进程的系统，每个进程中都有这样一段代码，它可能会修改一些与其他至少一个进程公用的数据，这段代码称为 critical section。这个系统需要满足的重要性质是：当一个进程正在运行它的 critical section 时，其他进程都不能进入它的 critical section。​我们将这个问题称为 Critical-section problem，也就是要设计一种达成这一性质的方法；或者说，设计一种能让各个进程 同步 (synchronize) 它们的活动，从而安全地共享数据的协议。​同步的核心意义是，规定进程所做的工作之间的顺序或者先序关系，从而防止一些非法情况的发生。​​每个进程必须在 entry section 中申请进入 critical section 的许可；在 critical section 运行结束后进入 exit section，在这里许可被释放。其他代码称为 remainder section。​Critical-section problem 的解决方法必须满足如下三个要求：​Mutual exclusion - 没有两个进程可以同时在运行 critical section​Progress - 系统整体上是在运行的，即要么有进程在运行它的 critical section，要么没有任何进程想要（将要，即在运行 critical section 之前的 section）进入 critical section，要么在有限时间内将有一个进程被选中进入它的 critical section​Bounded waiting - 任何一个进程等待进入 critical section 的时间是有限的。即，当一个进程提出一个进入 critical section 的请求后，只有有限个（次）进程会在它之前进入 critical section​对于单核系统，我们可以通过在 critical section 中禁止中断（即，在 entry section 中 disable，在 exit section 中 enable）的方式来实现上述功能（虽然可能是危险的）。​但是对于多核系统，中断禁止的消息要传到所有处理器，消息传递会延迟进入临界区，会降低效率；同时也会影响时钟中断。​我们需要保证 kernel 的设计实现了 critical section。Kernel 的实现分为两种类型，分别是 抢占式内核 preemptive kernel 和 非抢占式内核 nonpreemptive kernel，其区别是是否允许处于 kernel mode 的进程被抢占。​（但是实际上，非抢占式内核的实现是保证同一个时间点只有一个进程能在 kernel 里跑 [Ref1, Ref2] ——这种实现和前面概念的区别是，有可能有多个处理器；如果按前面的概念来说的话，并不能保证没有多个 CPU 同时跑在 kernel 里。）因此，非抢占式内核不会导致 kernel mode 的 race condition，因为在任一时间点只有一个进程能在 kernel 里跑，所以 kernel 用到的各种数据和资源也就只有它一个人用了！​抢占式内核相对而言更难设计，但是同时也能有更快的响应。我们后面来讨论设计抢占式内核，或者说设计出解决了 critical-section problem 的程序的方案。​Peterson's Solution​内容​Peterson's solution 基于一定的假设解决了两个 task 的 synchornization：​​其中， i 是 0 或 1，表示第 i 个进程； turn 是当前有权进入 critical section 的进程（0 或 1）； flag[i] 是第 i 个进程是否准备好进入 critical section，初始值均为 FALSE。​性质证明​​​Reordering​但实际上，Peterson's solution 在现代计算机体系结构上不一定适用，因为现代的处理器和编译器有可能会为了优化性能而对一些读写操作进行重排。在优化中，处理器或编译器会考虑其重排的合理性，即保证了在单线程程序中结果值是稳定且正确的。但是这不能保证其在多线程共用数据时的正确性，重排可能会导致不稳定或者不期望的输出。例如如果编译器将对 flag[i] 和 turn 赋值的顺序交换：​​Note that reordering of memory accesses can happen even on processors that don't reorder instructions (Src)​Memory Barrier​如我们之前所说，编译器和处理器会对代码的结构进行 reorder，以达到最佳效果。例如：​对 a2 和 b1 进行重排，使得不需反复读取交替 x 和 y 值​重排可能使得在多核运行时出现与期望不同的结果。为了解决这个问题，我们引入 Memory Barrier：它用来保证其之前的内存访问先于其后的完成。即，我们保证在此前对内存的改变对其他处理器上的进程是可见的。​​Memory model​另外，在现代的体系结构上，一个线程写了对应的变量后有可能不会立刻写回内存，这也有可能导致问题：How a computer architecture determines what memory guarantees it will provide to an application program is known as its memory model. In general, a memory model falls into one of two categories:1. Strongly ordered, where a memory modification on one processor is immediately visible to all other processors.2. Weakly ordered, where modifications to memory on one processor may not be immediately visible to other processors.​Hardware Inst.​许多现代系统提供硬件指令，用于检测和修改 word 的内容，或者用于 atomically（uniterruptably，不可被打断地） 交换两个 word。这里，我们不讨论特定机器的特定指令，而是通过指令 test_and_set() 和 compare_and_swap() 抽象了解这些指令背后的主要概念。​test_and_set​这一指令的重要要求是：它的执行是 atomic 的​我们可以在支持这个指令的机器上实现 mutual exclusive：定义一个 bool 变量 lock ，初始化为 false。进程的结构为：​​可见，如果 lock 在 Entry Section 时为 true，那么 test_and_set(&lock) 将返回 true，因此会始终在 while 循环中询问。直到某个时刻 lock 为 false，那么 test_and_set(&lock) 将返回 false 同时将 lock 置为 true，进程进入 Critical Section，同时保证其他进程无法进入 Critical Section。当持锁的进程完成 Critical Section 的运行，它在 Exit Section 中释放 lock ，从而允许其他进程进入 Critical Section。如果某个时刻 lock 为 false，而有两个或多个进程几乎同时调用了 test_and_set(&lock) 。但由于它是 atomic 的，因此只有一个进程可以返回 false。​但是，如上所示的控制不能满足 bounded waiting 条件：​​我们可以作如下更改以满足 bounded waiting：​​我们引入了 bool 数组 waiting[] 。在 Entry Section 中，我们首先置 waiting[i] 为 true；当 waiting[i] 或者 lock 中任意一个被释放时，进程可以进入 Critical Section。初始时， lock 为 false，第一个请求进入 CS 的进程可以获许运行。在 Exit Section 中，进程从下一个进程开始，遍历一遍所有进程，发现正在等待的进程时释放它的 waiting[j] ，使其获许进入 CS，当前进程继续 Remainder Section 的运行；如果没有任何进程在等待，那么它释放 lock ，使得之后第一个请求进入 CS 的进程可以直接获许。这样的方式可以保证每一个进程至多等待 n-1 个进程在其前面进入 CS，满足了 bounded waiting 条件。​compare_and_swap​同样，compare_and_swap() 的执行是 atomic 的。类似地，我们声明一个全局变量 lock ，初始值设为 0。​​可见，compare_and_swap() 和 test_and_set() 没有本质区别。上例 compare_and_swap()  的使用方法同样无法保证 bounded waiting，我们可以使用与 test_and_set() 同样的方式来解决。​Atomic Var​如我们先前所说，之前介绍的指令常被用来作为同步工具的组成部分而不是直接使用，我们可以使用 compare_and_swap() 指令来实现一些工具。其中一个工具就是 Atomic Variable。​一个变量在更新的过程中可能会导致一个 race condition。Atomic Variable 可以为数据提供 atomic updates。例如，我们使用不可打断的 increment(&count); 指令来代替可被打断的 count++ 指令就可以解决本节开头的 Bounded-buffer Problem：​​程序循环尝试将 v 赋值为 temp+1 ，当赋值成功时返回。由于 CAS 指令是 atomic 的，因此它不会在运行过程中被打断；在程序其他运行过程中 v 的值都没有发生改变。​但是需要注意的是，如果 buffer 有两个 consumer 在同时等待读取，那么当 count 由 0 变成 1 的时候两个 consumer 可能会同时进入来读取，但是实际上只有 1 个值在 buffer 中。即，Atomic Variable 并不能解决所有 race condition，因为它解决的问题仅是变量更新过程中的 race condition。​Mutex​我们尝试设计软件工具来解决 CS problem。我们讨论 Mutex (MUTual EXclusion) Lock 的实现，它通常被认为是最简单的 synchronization tool。​我们考虑让进程在 Entry Section 申请 acquire() 一个锁，然后在 Exit Section release() 一个锁。对于这个锁，我们用一个布尔变量来表示它是否 avaliable ：​​我们需要保证 acquire() 和 release() 是 atomic 的。我们可以使用 test_and_set() 和 compare_and_swap() 来实现：​​但是这种实现的缺点是，它需要 busy waiting，即当有一个进程在临界区中时，其他进程在请求进入临界区时会在 acquire() 中持续等待。​​可以发现，T1 在它的 CPU 时间内不断循环等待，直到 T0 释放锁。因此这种锁也成为 spinlock。​可以想象，如果有 N 个进程同时使用一个 CPU，那么将有大约 (N-1)/N 的时间被浪费。如果有进程在企图 acquire 一个锁时被阻止，我们称它是 contended（被争夺）；反之我们称它 uncontended。如我们所述，highly contended locks 会降低当前运行程序的整体性能。​我们还可以考虑下面的设计，其中 yield() 会使程序从 running 转为 ready，从而让出 CPU：​​不过，如果所需的等待时间一般小于 context switch 所需的时间的话，用 spinlock 可能是更好的。(Ref)​Semaphores​我们给出一种更厉害的 synchronization tool，称为 semaphore。一个 semaphore S 是一个整型变量，它除了初始化外只能通过两个 atomic 操作 wait() 和 signal() （原称为 P() 和 V() ）来访问：​需要重申的是， wait() 和 signal() 应该是 atomic 的。​有 2 种 semaphore：● Counting semaphore - S 的值不受限制；● Binary semaphore - S 的值只能是 0 或 1。类似于互斥锁。一个例子​但是，如同前面我们所说，semaphore 也具有 busy waiting 的问题。为了解决这个问题，我们可以为 semaphore 引入 waiting queue：​​但是，semaphore 可能会导致 deadlock：​​Priority Inversion​​这个问题称为 priority inversion，即具有中等优先级的 M 的运行时间反而影响了具有较高优先级的 H 的等待时间。​我们可以通过优先级继承 priority inheritance 来解决这一问题：所有正在访问资源（如上例中，低优先级的 L 所持的锁）的进程获得需要访问这个资源的更高优先级进程的优先级，直到它们用完有关资源为止。（如上例中，priority inheritance 将允许 L 临时继承 H 的优先级从而防止被 M 抢占；当 L 释放锁后则回到原来的优先级，此时 H 将在 M 之前执行。）​Sync Examples死锁Memory Management主存虚拟内存Storage ManagementFile System常用的图！","graphicsBBox":{"x":-625.800048828125,"y":60.79998779296875,"width":1125.0750732421875,"height":393}}