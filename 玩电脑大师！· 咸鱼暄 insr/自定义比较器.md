[3:28 PM] 解雲暄: 你好 请问仿函数的存在意义就是支持长得像函数的括号调用，但是因为有的地方必须传一个类型而不是一个函数指针吗<br />[3:31 PM] 刘腾: 额<br />[3:31 PM] 刘腾: 我觉得还有一个意义就是 函数也可以有一些变量<br />[3:31 PM] 解雲暄: 哦哦 类似闭包十八<br />[3:31 PM] 解雲暄: 是吧<br />[3:31 PM] 刘腾: 对<br />[3:31 PM] 刘腾: 函数闭包<br />[3:31 PM] 刘腾: 是的<br />[3:31 PM] 解雲暄: 我现在有一个疑惑<br />[3:31 PM] 解雲暄: sort是如何实现的<br />[3:32 PM] 解雲暄: 就是 它如何适配有自定义比较器的时候用comp(a, b)，没有的时候用 a < b 的<br />[3:32 PM] 解雲暄: 感觉可能是两个不同的特化<br />[3:33 PM] 刘腾: 也可以是缺省参数 xxx = std::less<T><br />[3:33 PM] 刘腾: 我猜测<br />[3:33 PM] 刘腾: 如果根本实例化不出来 std::less<T> 说明不能不自定义比较器直接比较类型 T<br />[3:34 PM] 刘腾: 不太懂 你可以看一下 glibc++<br />[3:34 PM] 解雲暄: 懂了<br />[3:34 PM] 解雲暄: 我蠢了<br />[3:34 PM] 解雲暄: 函数重载而已<br />[3:34 PM] 解雲暄: 两个或三个参数<br />[3:34 PM] 刘腾: 合理<br />[3:34 PM] 刘腾: 正确的完全<br />[3:35 PM] 解雲暄: 我仍然不理解的是 何时只能用functor而不能用函数指针<br />[3:35 PM] 解雲暄: 有例子吗<br />[3:35 PM] 解雲暄: 比如优先队列<br />[3:36 PM] 刘腾: 我觉得如果他想<br />[3:36 PM] 解雲暄: 哦 我懂了<br />[3:36 PM] 解雲暄: 应该是可以的<br />[3:36 PM] 解雲暄: 但是不行<br />[3:37 PM] 刘腾: 一定能让能用functor的时候也能用函数指针<br />[3:37 PM] 解雲暄: 我理解了 因为functor的类型里同时包含了类型和实现<br />[3:37 PM] 解雲暄: 而函数指针我要么 decltype(comp)，只包含类型<br />[3:37 PM] 解雲暄: 要么 comp，只包含实现<br />[3:37 PM] 解雲暄: 不过<br />[3:37 PM] 解雲暄: 所以<br />[3:38 PM] 解雲暄: 有时如果这个东西必须用类型给出<br />[3:38 PM] 解雲暄: ‘那就只能用functor<br />[3:38 PM] 刘腾: 什么时候<br />[3:38 PM] 刘腾: 必须用类型给出呢<br />[3:40 PM] 解雲暄: 好像没有<br />[3:40 PM] 刘腾: 我感觉好像没有特别的意义<br />[3:40 PM] 刘腾: 除了增加环境变量<br />[3:40 PM] 刘腾: 给函数<br />[3:42 PM] 解雲暄: 
![image.png](./assets/1663660016121-e5e97445-5421-4fbd-b4b6-c6f8ce341622.png)
[3:42 PM] 解雲暄: 其实<br />[3:42 PM] 解雲暄: 确实<br />[3:43 PM] 解雲暄: 这样也可以使用<br />[3:43 PM] 解雲暄: 所以只要能 comp(a, b) 这样调用的都可以<br />[3:43 PM] 解雲暄: 合理<br />[3:43 PM] 刘腾: 唯一的区别就是<br />[3:44 PM] 刘腾: 函数指针必须在定义变量的时候比如这里的q<br />[3:44 PM] 刘腾: 必须把函数指针的实例传进去<br />[3:44 PM] 解雲暄: 是的<br />[3:44 PM] 刘腾: 告诉他实现<br />[3:44 PM] 解雲暄: 我看了<br />[3:44 PM] 刘腾: 但是 functor 可以不传<br />[3:44 PM] 解雲暄: 如果没有这个参数<br />[3:44 PM] 刘腾: 是否如此<br />[3:44 PM] 解雲暄: 他就默认 comp = Compare()
[3:44 PM] 刘腾: 噢噢<br />[3:44 PM] 刘腾: 原来如此<br />[3:44 PM] 刘腾: 非常合理之<br />[3:44 PM] 解雲暄: 我大成了
