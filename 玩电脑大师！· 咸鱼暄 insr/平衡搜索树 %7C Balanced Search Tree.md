:::danger
文档现在有点问题）以前的版本：[https://www.yuque.com/r/doc_versions/405074019](https://www.yuque.com/r/doc_versions/405074019)
:::


本文介绍了平衡二叉树的优势，并介绍了几种常见的平衡二叉搜索树的实现方法及思路；介绍了 B+ 树的思路和实现。

:::success
后文中，如此形式的绿色框中包含的是对该数据结构 / 算法的一些思考。<br />若无特殊说明，本文的图片均来自 cyll 的课件；但有些是为了补充思考过程，对其加以一定修改的结果。
:::

## 1 引入
我们在 [二叉查找树 ADT | Binary Search Trees](https://www.yuque.com/xianyuxuan/coding/dzciqf?view=doc_embed) 中曾经学过 Binary Search Tree 这一数据结构。BST 的意义是提高搜索效率。我们可以在 BST 中进行结点的插入和删除，每一次搜索的需要花费的时间与树的高度成正比；即 。理想情况下（如 Complete BST），树高可达 


## 2 平衡二叉树 | Balanced Binary Tree

### 2.1 定义
我们给出 **平衡二叉树** 的定义：

   - 空二叉树是平衡二叉树；
   - 如果一棵二叉树 ![](https://cdn.nlark.com/yuque/__latex/b9ece18c950afbfa6b0fdbfa4ff731d3.svg#card=math&code=T&height=16&id=pFRev) 不是空二叉树，其左子树和右子树分别为 ，我们称 **height balanced**) ，当且仅当：
      - ![](https://cdn.nlark.com/yuque/__latex/1df1a41e4ba913588d077865613180c4.svg#card=math&code=T_L%2C%20T_R&height=18&id=S0qjd) 是高度平衡的树；而且
      - ![](https://cdn.nlark.com/yuque/__latex/2b7366bd3af42dd45dd7e19b8dee6d84.svg#card=math&code=%7Ch%28T_L%29%20-%20h%28T_R%29%7C%5Cleq1&height=20&id=cekvC)


### 2.2 平衡因子
我们定义 **平衡因子 (balance factor)** ![](https://cdn.nlark.com/yuque/__latex/5b0d3b1668a7c9c50a8e5784d1567a1e.svg#card=math&code=BF%28node%29%20%3D%20h%28T_L%29%20-%20h%28T_R%29&height=20&id=SDBvK)，即某个结点的平衡因子为其左子树的高度减去其右子树的高度。显然，平衡因子可以为负值。

:::warning
请注意：不同的资料中 BF 的定义有所不同，有的地方的定义为右子树高减去左子树高，即上述算法的相反数。我们采取此处正文中的规定从而与课程一致；这对算法的理解和分析影响不大，但也需注意区分。
:::


### 2.3 分析
我们分析一棵平衡二叉树的高度与结点个数的关系。对于一棵高度为 _h_ 的平衡二叉树，使其结点数最少的形式必然为如下之一：
![image.png](./assets/1614942211348-c2cf8cd2-d725-405a-aa6c-a35bdf7fba7f.png)
我们用 ![](https://cdn.nlark.com/yuque/__latex/4a0a6f9a15ed275ce4402abd25ce8c76.svg#card=math&code=n_h&height=14&id=zUzMF) 表示高度为 _h_ 的平衡二叉树的最小结点数，我们得到递推关系：![](https://cdn.nlark.com/yuque/__latex/d68381914625e2be8727d0513a212691.svg#card=math&code=n_1%20%3D%201%2C%20n_2%20%3D%202%2C&height=18&id=iaMNe)![](https://cdn.nlark.com/yuque/__latex/c9a1e2d64ad211ae60076091fa9b5d2b.svg#card=math&code=n_h%20%3D%20n_%7Bh-1%7D%20%2B%20n_%7Bh-2%7D%20%2B%201&height=18&id=eZQQ7)，即  是一个斐波那契数列。我们知道斐波那契数列以指数形式增长，因此我们有 <br />因此，平衡二叉搜索树上进行查找等操作的时间复杂度为 。

## 3 AVL Tree | Adelson-Velskii-Landis Tree

### 3.1 定义及思想
AVL Tree 是首先被提出的动态平衡二叉搜索树（即在不断插入中保持平衡的二叉搜索树），其命名是其两个提出者的名字。<br />**AVL Tree** 中每个节点的平衡因子只为 -1, 0, 1 中的一个。即，AVL Tree 的核心思想是，当插入一个结点时，检查会不会出现不满足要求的 _BF_ ，如果有，采取适当方法来调整这棵树从而让其满足该性质。


### 3.2 维护：旋转 (Rotation)
我们讨论插入一个新的结点到 AVL Tree 时会发生的事情，以及如何来解决插入带来的问题。

#### 3.2.1 RR / LL Rotation
举一个例子：
![image.png](./assets/1614934688523-c86f81d6-4fd7-464a-845f-4270b2b0cbb8.png)
我们在如图所示的 AVL Tree 中插入了新的结点 `Nov` ，我们会发现插入这个结点后，这棵树不再是一个 AVL Tree（左边）。我们可以发现，右边的形式是这三个结点能够构造出的唯一一种 AVL Tree。分析这两棵树我们发现，我们实际上是对左边这棵树 **做了一次旋转** ，将 `Mar` 由根节点放到了左下方，变成了右边的形式。

:::success
我们来考虑这个问题：有一个结点的 BF 为 -2，说明刚刚插入的一个结点使得其左子树和右子树的高度有了 2 的差距，这个差距之前一定是 1，因为一个结点的加入不可能导致 >1 个高度的差距；但是如果我们通过类似于上面问题中的“旋转”来进行调整，就有可能将树的位置进行重新排列，让 -1 => -2 这样的变化变为 -1 => 0，或者 -1 => -1。

我们同时也可以发现，如果 `Mar` 并非根节点，而是某一棵子树的根节点，那么进行这种旋转，让 `May` 代替其位置成为这棵子树的根节点的话，这种调整的正确性并不会受影响，而且调整后的子树高度与没有插入 `Nov` 结点时的高度是一样的。这说明，这样的调整具有 **局部性**：既不会受到其他部分的影响，也不会影响到其他部分满足性质。
:::

我们可以容易地给出更加一般化的情况：在下面这张图片中， `A` 结点的 BF 是 -1，表示右子树高于左子树 1；这时再插入一个结点使得右子树 `B` 的右子树 `B_R` 高度 +1，就会使得 `A` 的 BF 变成 -2，破坏了 AVL Tree 的性质。我们做一个旋转：让 `B` 代替 `A` 的位置（如我们之前所说，`A` 不一定是根节点）， `A` 变成 `B` 的左子树，这样，各点的 BF 就都满足要求了。
![image.png](./assets/1614939058278-8f474cfa-f905-4c4e-84f4-f6a11967209d.png)
:::success
这进一步说明了这种调整的 **局部性**：调整只与 `A` 和 `B` 有关，与 `A_L` 和 `B_R` 的具体内容无关。从下面更一般的情况中我们可以发现，它与 `B_L` 的内容也无关。
:::

更一般地，考虑结点 `B`  有左子树的情况。解决方法非常简单：我们让 B 的左子树 `B_L` 成为 `A` 的右子树。由于 ![](https://cdn.nlark.com/yuque/__latex/fdd03e579348ba33fbfc416af7615d2d.svg#card=math&code=%5Cforall%20%5Ctext%7B%20node%20%7DN%5Cin%20B_L%2C%5C%20A%5Cleq%20N%5Cleq%20B&height=18&id=W0q8h)，因此这样做不影响 BST 的性质。
![image.png](./assets/1614933301805-ef5ebbb4-edf5-48be-bedb-a6fa6e4d9221.png)

这种旋转称为 **RR Rotation**，指不满足性质的结点 `A` 的**右**子树 `B` 的**右**子树 `B_R` 引起的问题；由于旋转的方向向左，我们也称之为 **左旋** 。<br />需要理解的是，我们这里的 `A` 是首个不满足 AVL Tree 性质的结点，因为当我们插入一个结点时，我们在递归的返回过程中更新树高并检查 BF 值是否合理；亦即，我们是由底向上对 AVL Tree 进行维护的。这里 `A_L` , `B_L` , `B_R` 都是满足 AVL Tree 性质的，否则我们会首先处理它们的维护。<br />这种维护的实现只需要我们找到图中的 `A` , `B` 两个结点；事实上，我们其实是先找到这两个结点，才判定使用 RR Rotation 的。我们首先注意到 `A` ，因为它是第一个出现 BF 超出范围的结点；而 `A` 的 BF 值为负值，说明问题出现在右子树 `B` 中， `B` 进一步发现是其右子树引发了问题，因此判定使用 RR Rotation。由于 RR Rotation 优秀的局部特性，我们只需要找到这两个点，而不需要关注它们的子树以及 `A` 的父亲节点都有什么。

**LL Rotation** 与此恰好对称，在此不再赘述。
![image.png](./assets/1614936445090-2d7690bd-e15e-4e03-a4a9-91092a9ca1f3.png)

:::success
我们刚才说明了 RR Rotation 不会影响 BST 性质的原因，即结点和子树之间的大小关系允许了这种旋转：某个结点 `X` 的右子树 `R` 的左子树 `R_L` 中的值一定是满足 `X <= R_L <= R` 的，因此我们也可以让 `X` 成为 `R` 的左子树，让 `R_L` 成为 `X` 的右子树； `X` 的左子树 `L` 和 `R` 的右子树 `R_R` 仍然保持原状，但 RR Rotation 会使得 `L` 的高度 +1， `R_R` 的高度 -1，这就是“旋转”及其合法性的原理。<br />但是，旋转并不改变 `R_L` 的高度。因此，如果插入结点使得 `R_L` 的高度 +1，通过上面所述的旋转就不能解决，我们需要寻找其他的办法。
![image.png](./assets/1614939605036-515e1536-98e6-42bb-a561-be645dd0448f.png)
:::


#### 3.2.2 RL / LR Rotation
我们在上一节说明了上面的旋转方式并不能够解决 LR 或者 RL 类型的问题；但是“旋转”是一个非常经济和值得研究的方式，因为我们之前提到：既然一个结点能够让 BF 从 -1 变成 -2，那么一定能够找到操作使得 BF 从 -1 变成 0。
:::danger
问题：AVL Tree 的旋转一定会使得调整前 BF 为 ±2 的点的 BF 变成 0 吗？
:::

我们考虑 RL 插入的情形：
![image.png](./assets/1614939377456-216a8ac0-49cf-46ea-9500-4039e32cbbbe.png)
:::success
首先，如同 3.2.1 那样的旋转方法不能改变 `B_L` 的高度，因此旋转不能解决当前的问题，因此我们需要对当前的树结构进行进一步划分从而满足旋转的需要。我们也需要意识到：由于 BST 的性质， ![](https://cdn.nlark.com/yuque/__latex/c93024da92eacc7ce50abc028a190850.svg#card=math&code=A_L%20%5Cleq%20A%20%5Cleq%20B%5Cleq%20B_R&height=18&id=j6uxZ)，因此 `A_L` 仍应当是 `A` 的左子树， `B_R` 仍应当是 `B` 的右子树，这两个部分如果进行再分也是没有意义的。因此我们应当着眼于 `B_L` 考虑旋转的策略。
:::

我们将 `B_L` 再分成如下左图所示的形式。我们首先考虑插入的结点使得 `C_L` 的高度增加的情形（右图）：
![image.png](./assets/1614940753992-889e7886-998e-48a4-8b94-8274d85e737f.png)
:::success
我们首先分析左图中各部分的大小关系：![](https://cdn.nlark.com/yuque/__latex/85c0dd70051654807f4db3f27bd3b9df.svg#card=math&code=A_L%5Cleq%20A%5Cleq%20C_L%5Cleq%20C%5Cleq%20C_R%5Cleq%20B%5Cleq%20B_R&height=18&id=RYwdh)。我们希望让 `C_L` 的深度变低， `A_L` 的深度变深。显然，为了让 `A_L` 变深，我们只能让 `A` 变深，即考虑让其他结点成为根节点。我们已经说明了 `B` 成为根节点不能解决问题，那么我们考虑让 `C` 成为根节点， `A` 和 `B` 自然分别成为其左、右子节点， `C_L` 和 `C_R` 自然只能成为 `A` 的右子树和 `B` 的左子树，即：
:::
![image.png](./assets/1614940418352-f9618678-0f6d-4362-8ed5-b16373250afd.png)
进一步我们可以发现，插入结点使得 `C_R` 高度增加不影响上述方法的正确性，即：
![image.png](./assets/1614940517289-92646617-ba0a-475f-bc9f-0964cb8a11ff.png)
实际上，这种调整经历了两步旋转。第一步是 B 和 C 之间的，与 LL Rotation 一样的操作；第二步是 A 和 C 之间的，与 RR Rotation 一样的操作（也就是说，我们实现这种调整时，可以重用 RR/LL 的代码）：
![image.png](./assets/1614941024295-846720c7-9360-42bd-8ddb-001fd54b40a7.png)
这种旋转称为 **RL Rotation** 。对称地， **LR Rotation** ：
![image.png](./assets/1614940593681-c8b5671e-2f2a-48ca-950f-039a209bd4b0.png)
:::success
分析 RL / LR Rotation 我们可以发现，这两种调整方式与 LL / RR 有同样的 **局部** 特性。即：我们可以只找到 `A` , `B` , `C` 这三个结点，而不需要关注它们的子树以及 `A` 的父亲节点（如果有）到底有什么。这也是这种数据结构和调整策略的优秀之处。
:::


## 4 伸展树 | Splay Tree


## 5 红黑树 | Red-Black Tree

### 5.1 定义

#### 5.1.1 NIL / NULL Leaves
我们之前将没有子结点的结点称为叶子结点；但是在红黑树中，我们认为树中存在的结点 (internal nodes) 如果有子结点为空，那么该空子结点为叶子结点 (NULL leaf)，称为外部结点 (external nodes)，用 `NULL` 或 `NIL` 标记。


#### 5.1.2 R-B Tree
一棵** 红黑树** 是一个 BST，且满足如下性质：

1. 每个节点是红色或黑色之一；
2. 根节点是黑色；
3. 所有的叶子结点（NIL）都是黑色；
4. 如果一个结点为红色，那么它的子结点都是黑色：即，不存在一条路径上有两个连续的红色结点，但可以有连续的黑色结点；
5. 对于每一个结点，从其出发到任意一个叶子结点的路径上的黑色结点数目均相等。

我们可以注意到，红黑树不一定满足 2 中“平衡二叉树”的定义，例如下图所示是一棵红黑树，但并不是一棵平衡二叉树；但我们会在 5.2 中分析红黑树的特点。
![image.png](./assets/1615258760080-7ecf0b69-f4bb-4d08-860c-4b46a7f202e9.png)

#### 5.1.3 Black-Height
对于任意结点 _x_，我们定义它的 black-height _bh(x)_ 为从该结点开始到一个 NIL 结点上黑色结点的个数（x 结点本身不计）。<br />我们定义一棵树的 _bh_ 为其根节点的 _bh_。

:::danger
太阴了：![image.png](./assets/1620702696592-34396f4f-1170-42f9-82a4-aec72aa92fd1.png)
（所以 bh 不能不数 NIL）
:::



### 5.2 分析
我们在 5.1.2 中提到，红黑树并没有平衡二叉树那么平衡。但是我们可以发现，**对于红黑树上的每一个结点，从它出发到任意叶子结点的路径中，最长的路径不超过最短路径长度的二倍**。这是因为，该节点的 _bh_ 是一定的，最短的情况为路径上全部为黑色结点，长度为 _bh_；而由于红色结点不能连续，最长的情况为红、黑交替，最长为 _2*bh_。因此，红黑树在这种意义上也是平衡的。下面我们进行更加具体的分析：

首先我们用数学归纳法证明，对任意结点 _x_，以它为根节点的（子）树中内部节点的个数（记为 _sizeof(x)_ ）满足关系 ![](https://cdn.nlark.com/yuque/__latex/c14ba438d31fa81775016be8dcf1c7dc.svg#card=math&code=%5Ctext%7Bsizeof%7D%28x%29%5Cgeq%202%5E%7B%5Ctext%7Bbh%7D%28x%29%7D%20-%201&height=24&id=GaisP)：

我们说明了有 ![](https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&code=N&height=16&id=dgCuw) 个内部结点的红黑树，其高度不大于 。


### 5.3 Insert()
当我们在红黑树中插入一个新的结点时，由于性质 1 的要求，我们必须使其为红色结点或黑色结点之一。但是我们可以发现，如果插入的结点涂为黑色，那么整棵树上其他路径的 _bh_ 都会因此改变，我们需要对此做出大量调整，这是不经济的；而如果插入的结点涂为红色，我们只需要做局部调整就有可能解决性质 4 的问题。因此我们插入的核心思路是：将新的结点涂为红色，并通过一些操作来维护红黑树的性质。

插入操作有可能有如下几种情况：

- 如果要插入结点的父亲为黑色结点，那么什么都不会发生

![image.png](./assets/1615259483908-ea70270a-ba44-4b1f-9d46-0052184ecdf3.png)

- 如果要插入结点的父亲为红色结点，我们进行进一步细化分析：
   - **Case 1**：如果其父亲的兄弟也是红色，那么我们将祖父结点设为红色，并将父亲结点及其兄弟设为黑色：

![image.png](./assets/1615259665686-5921ecbc-af02-4286-88d4-b83f35fbb7d1.png)
 ![image.png](./assets/1615259630630-477cc82b-1eb5-44db-a100-79ea0e64758e.png)
进行更改后，我们需要继续检查其祖父改为红色是否违反性质 4。我们再次发现了问题：

   - **Case 2**：如果父亲的兄弟是黑色，且当前节点为父亲的右子结点，那么我们首先对这两个红色的结点做左旋（就像 RR Rotation 那样）：

![image.png](./assets/1615260069119-3a689711-8b98-4314-b76d-0d52c1da00e2.png)
![image.png](./assets/1615260039497-3d25e27a-1a45-4ace-830b-e310826e7fb8.png)
这样旋转，是为了将 Case 2 划归到 Case 3 的情况解决：

   - **Case 3**：如果父亲的兄弟是黑色，且当前节点为父亲的左子节点，那么我们首先将祖父结点设为红色，将父亲节点设为黑色，然后做一次右旋：

![image.png](./assets/1615260250318-bda0b480-2c41-42a5-8239-a4699a7f7f4d.png)
![image.png](./assets/1615260223859-ed4a473e-f58e-471c-bccb-5ab1c429ed07.png)
以上三种情况均考虑违反性质 4 的现象发生在祖父结点的左子树；对于发生在右子树的状态，与此对称。
![image.png](./assets/1615260447439-39cff4ec-2254-4d30-a096-57fd06fff537.png)

在最坏的情形下，我们会用 Case 1 不断更新颜色，找到 Case 2，经旋转达到 Case 3，做第二次旋转。也就是说，我们最多会进行两次旋转，这与 AVL Tree 是一样的。因此，插入操作的时间复杂度为：<br />![](https://cdn.nlark.com/yuque/__latex/c2dfe7cd8dc33467e407fb5d65bb93e9.svg#card=math&code=T%20%3D%20O%28h%29%20%3D%20O%28%5Cln%20N%29&height=20&id=pqcyo)


### 5.4 Delete()



## 6 B+ Tree
