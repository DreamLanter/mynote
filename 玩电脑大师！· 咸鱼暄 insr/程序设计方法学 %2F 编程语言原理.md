
# Principals of Programming Language

## <br />

**_Lec 1 - 21.9.15_**

---


## 1 Introduction

#### Assessment

- 5% 课内
- 15% 单元小作业
- 10% 文献综述
- 30% 解释器
- 40% 期末考试（闭卷，全部主观题，一般 10 道问答题）

课程编号体系<br />“表达是比词汇更重要/更难学的东西”<br />“诸暨人不认为自己是绍兴人，萧山人不认为自己是杭州人”<br />“天津的妈祖文化是从福建带过去的”<br />Artificial Science - Computer Science 不算 Natural Science 更不算 Social Science<br />“双水内冷电机楼”<br />“我们只要在中小学的教科书里把黑板叫桌子，过几代人以后这个东西就叫桌子”<br />“西溪路上那个门本来叫后门，03 04 年的样子叫成了北门，近年学校的官方文件才慢慢变成了北门”<br />“浙大曾经有个自建的 BBS 叫 88，在这个文化圈子里新的词汇会很快传播”<br />“现在 88 消亡了，98 也渐渐消亡了”<br />“活得久不是个坏事，可以看到很多东西的变化和消亡”<br />“玉泉校区叫教四教七，北大清华叫一教二教三教四教”<br />“之前教四 406 是直接写 IV406，今天已经没有了”

语言是一种向其他人表达自己想法的方式<br />编程语言是一种表达计算或算法且可由计算机执行的人造语言<br />_A Discipline of Programming_, Edsger W. Dijkstra<br />“形式化验证”<br />“你去国外听老师讲课，能听懂，回去想一想老师讲了什么，发现脑子里记的都是汉语”<br />“我们的思考建立在语言的基础上”

type-safe languages 越来越多<br />expressing algorithm > syntax<br />“普通话是一个简化了的人造语言；去掉了很多丰富的东西”<br />“普通话每个字的读音都是等长的。方言不是”


#### Topics

- 编程语言基本概念
- 编程语言基本元素
- 编程语言设计范式与实现
- 函数式计算、并行计算和递归计算

Optional 避免空指针异常

MUA - Make Up A language<br />“但是 MUA 是个很好的词对吧，你们发一下音就知道什么意思了”<br />“对，就是那个 HugHug KissKiss 那个对吧”<br />“这个语言的设计不需要你学习了编译的知识就能写这个解释器”<br />“你想用 MUA 来写 MUA 的解释器也可以，但是你得再给我一个 MUA 的解释器来解释你的 MUA 然后才能……这也是可行的对吧”<br />“今年打算把闭包加上。闭包是一个听起来简单实现起来不容易的东西”


#### 编程语言的分类

##### Imperative 命令式编程语言
拿一个命令做一个操作。冯诺依曼架构就是这么做的，我们的编程语言模拟了这个架构。<br />程序的过程中会有变量，我们用变量来存储数据。至于变量在哪我们不关心。我们也不关心相邻两个变量是不是在相邻的位置上。我们学 C 语言的时候犯的一些错误可能会导致我们需要知道这些事情；但是实际上如果我我们在一些更脱离底层的语言中写代码的时候，我们从来不关心这个事情。<br />“大学以前都叫小朋友”<br />我们给小朋友讲什么是变量的时候，我们告诉他们变量是一个一个格子，格子里面放数据。现在我们可能认为变量是给数据起的名字。<br />CPU 取一个机器码然后去执行也是一个解释的过程。<br />最开始的“计算机”是把程序焊在电路板上。冯诺依曼：能不能让程序像数据一样放在存储器里。

**_Lec 2 - 21.9.22_**

---


##### Functional 函数式编程语言
数学和 C 语言中的函数的区别：数学的函数没有任何副作用，也不受任何副作用的影响。数学的函数给定一个确定的输入一定能得到一个确定的输出。<br />C 里面的句子分为语句和表达式；语句没有结果（比如 if），但是表达式有结果（如赋值）。<br />`i++` 的结果是 `i` 的值，副作用是 `i` 被赋值为 `i+1` 的值。 <br />LISP 所有的计算都是没有副作用的；所有的循环都是用递归进行。<br />流式计算


##### Logical 逻辑式编程语言
Prolog


## 2 早期编程语言的早期历史
![image.png](./assets/1636103643413-9ea5913b-6ba6-40c5-8a8c-e650cc8e3903.png)

#### 评价编程语言的指标

- Readability
   - 程序的可读性。“不是你不会，但是因为这个语言设计的不好，你读的时候会有误解。”
   - C 语言表达式里有赋值，会给阅读带来非常大的障碍。
   - “南宋的时候河南住的人和今天住在河南的人完全不是一批人”
   - “现在福建和广东的客家话和南宋的时候的河南话是类似的”
   - “杭州话作为语言孤岛的原因是长期作为首府，导致这里的人使用的是书面语词汇”
   - “宁波话比较特殊的原因是宁波东边就是舟山，舟山再东边就是海啦，所以宁波话才是语言孤岛”
   - 功能、基本结构越少越好读
      - “俄国人写的英文论文经常会有我们不认识的单词；我们去查了之后会发现我们通常会用另外的单词去表达”
      - 作者使用的的 subset 和读者熟悉的 subset 不一样的时候就会引发可读性的问题
   - 较少的重复 feature、较少的运算符重载
   - 正交性 Orthogonality
      - 相对较小的原始结构，可以被相对较少的方式结合；但每一种结合都是合法的，并且与上下文独立，没有副作用，不影响其他部分的运行。
   - 有效的控制语句
      - 看的时候不需要来回跳
   - 充足的定义数据类型和结构的方式
   - 灵活和清晰的语法规则
- Writability
   - 用这个语言写程序好不好写
   - 简单和正交
   - 对一些抽象（或者省略）的支持
   - 表达能力，实现一些操作的相对方便的方法，如 for 语句
- Reliability
   - 类型检查
   - 异常处理
   - 别名使用
      - 同一内存位置存在两种或多种不同的引用方法
   - Readability 和 Writability
      - 不支持自然方式表达算法的语言必然会使用非自然的方法实现，从而降低可靠性
- Cost
   - 学习成本、编写代码成本、编译成本、运行成本、维护成本等
- 其他考量
   - 可移植性、通用性、定义的完整性、能量利用率
- Trade-Offs
   - 可靠性和运行成本（动态类型检查）
   - 易读性和易写性
   - 编写代码的灵活性和可靠性

**_Lec 3 - 21.9.29_**

---


## 3 Syntax & Semantic

“杭州和杭州市有什么区别？浙江和浙江省有什么区别？北方来的同学可能不太清楚；为什么萧山人要坚持说自己不是杭州人，为什么诸暨人要说自己不是绍兴人。地理和行政区划和政府机构是三个不同的概念。杭州是一个表示地点的名词；杭州市有两种可能，第一种是表示这个行政区划；另一种是表示杭州市人民政府。”

语法用一些规则定义；语义则更加复杂，较难定义。
![image.png](./assets/1636107463219-97941fbc-2941-42e8-8bc0-b4fe78638b24.png)


#### Language & Sentence
一个 language 是 sentence 的集合；sentence 是由某个 alphabet 上的一串字符组成的。

   - 能够被 C 编译器编译的一个 C 程序就是 C language 的一个 sentence（不管它有多长）。
   - 一本英语书就是英语这个 language 的一个 sentence。

![image.png](./assets/1636107886621-479ba0f9-1b06-4c9e-a51a-e8e14a8a3265.png)
把 `main` 换成 `mian` 还是能过编译的；只是链接过不了。
![image.png](./assets/1636108047303-6c339121-0b61-49a2-83ff-c705fde4d652.png)
![image.png](./assets/1636108226521-4be975e6-b64a-436a-9110-c10c1e210f65.png)
如何检查一个 sentence 是否 in the language X？我们可以尝试 generate 这个 sentence。这个过程称为 **parse**。
![image.png](./assets/1636108483975-53d4e9f3-cd9b-4215-869c-a2851868ba8c.png)


#### BNF, Backus-Naur Form
![image.png](./assets/1636108587994-9d60650d-3fe9-4c84-8ab2-5b01820850a6.png)
具体的在编译原理学过了）

**_Lec 4 - 21.10.13_**

---


## 4 Names, Binding and Scope

变量是内存单元的一种抽象 / 变量是数据的名字
![image.png](./assets/1636113750255-97f0fbea-6a99-4f29-8029-25140bc8d36c.png)
实际上，C 语言编译时会有一个 Stack 的确切大小上限。这一限制是为了适应多线程的要求；另一个线程直接在前一个线程的大小上限后面的位置开始 stack。堆、静态存储区和代码区是各线程共用的。<br />“比如说你喜欢伪装自己是 70 年代的，那你就可以考虑变量全部用小写字母然后用下划线连接，显得自己是很古老的人，非常有历史渊源；你想显得正常一点那你就用驼峰。”

Python 所有变量都是指针。<br />类型重不重要？<br />Python 现在也支持类型定义了。

![image.png](./assets/1636115731730-0a9f95ba-8562-4764-aeaf-8373b955b5c3.png)
![image.png](./assets/1636115763533-cfb9b147-c628-4178-8b17-eb461ff78a2b.png)
![image.png](./assets/1636115776103-e87466ab-9e5f-4b32-b46a-ab2233f610b5.png)

- 静态变量
- 栈上的动态变量
   - 现在的 CPU 对静态变量访问反而没有栈上的局部变量快。
- 显式的堆上的动态变量
   - C++ 的 `malloc` 或者 `new`
   - “C++ 之后再也没有哪个语言需要手动回收了”
   - “你可能有情怀是吧，但是这是另一个故事”
   - “人类已经是一个和机器共生的物种了。所以不要拒绝机器”
   - “我们有的时候在思考这些问题的时候啊，要跳脱出自己是一个学生等等这样的身份。你要站在一个，作为一个物种和其他物种竞争的地球，作为一个地球和其他星球竞争的宇宙这样一个高度去理解这些事情”
   - “把自己交给一个机器没有什么不好的，没有什么可耻的”
   - “所以，为什么我要说这些，就是说机器自动回收内存是一个非常美好的事儿，我们今天已经没有人拒绝他了”
- 隐式的堆上的动态变量
   - 通过赋值而不是定义产生的分配


- 在 Java 里，同一个函数内，大括号外面定义过的变量在大括号内是不能重新定义的

Python 中这样可以输出正确结果（如果 a 不是 0 会 RE）：
```python
a = 0
if a == 0:
	i = 1
print(i)
```
C++ 不行：
```cpp
int main() {
    int a = 0;
    if (a == 0)
        int i = 1;
    cout << i;
}
```


## 5 Type
好像确实没讲<br />**_Lec 5 - 21.10.20_**

---


## 6 Expression

- 论文之外，大家可以在什么什么乎之类的网站找到很多很多的资料
- 优先级、结合性、顺序、副作用、运算符重载、混合类型的运算
- C 语言里 `6 < a < 10` 一定是 true，但是 Python 里就表示 `6 < a and a < 10`
- 有副作用的函数做并行就很难过：`b = foo1(&a) + foo2(&a)`
- 所以函数式编程天生就适合做并行
- 赋值运算符是有副作用的（结果 / 副作用）
- `printf` 的结果是输出了几个字节，`scanf` 的结果是读了几个变量
- 如果一个线程运行 `foo()`，它挂起了，另一个线程运行 `foo()` 不会影响前面那个线程的运行结果，那这个函数就是可重入的
   - 有副作用的函数（有全局变量 / 静态本地变量）的函数是不可重入的
      - 静态本地变量和全局变量只是作用域不同
      - 这样的函数运行的时候需要加锁
- 我没有强迫大家一定要学 Python 嗷。不过 2021 年了，你如果说……2021 年了如果你对 Python 还……不那么感兴趣的话这可能是个稍微有点危险的事情
- 80 年代 各行各业都在学 basic，觉得学了 basic 以后就可以写点程序解决自己手头的问题了，这个场景就是今天的 Python。而当时就是，确实没有任何一个高校的计算机专业会开 basic 这门课，但是中国有一些不入流的高校开过 basic 的课我们就不说了
- 可以跑 micro python 解释器的芯片的价格 已经到十块钱人民币了
- 一个可以联网的传感器，以前我们会选择树莓派，因为他有 Linux，但是一台树莓派要三百多块钱
- 跑 Linux 的硬件要求是 MMU，因为 Linux 是一个多进程操作系统，进程之间的虚拟内存是靠 MMU 完成的
- 最便宜的有 MMU 的芯片也要五十块
- 解决函数副作用的方法
   - 设计语言不允许函数副作用；但是 inflexible
   - 规定操作符计算顺序是固定的；但是限制了编译器优化
      - 例如 Java 要求都是从左向右算的
- 不是说不能有副作用，只是要消除副作用的负面影响
- 我们吃食物 就是要那个副作用 而不是要那个结果
- C 语言中的运算符重载
   - `+`，对于不同的指针类型
   - `>>`，在 signed 和 unsigned
   - `*`，乘法 / 定义指针 / 取值（`int *p` 里 * 只是个标点符号）
   - `,`，`f(a, b)` 和 `a = 6, b = 7` （前者里 * 也只是个标点符号）
- 类型转换
- 关系运算
- 短路计算 Short Circuit Evaluation
- C 语言那样把赋值当表达式的不多，大多数语言还是把赋值当做一个语句的
- 没有任何语句的语言 - 所有的 op 都是有返回值的（LISP, MUA）

**_Lec 6 - 21.10.27_**

---


## 7 Control

- LISP MUA 没有循环
- Java 的 break, continue 带标号，没有 goto
- Python 给 while 和 for 都带上了 else
- 新的语言里之前那种 for 已经没有了，Python 就只有 foreach 那种 for 了
- 表达式用的是 load & store 和 ALU
- control 用的是跳转
- if 和 else，Python 按缩进匹配，Java 和 C 按最近匹配
- Java 刚开始就很好地实现了字符串的 hash，因此 Java 支持 switch 字符串；实际上是一个语法糖
- switch-case 在有些场合很好用，但是 
   - 对初学者来说，break 不好理解，因为 case 只是语句标号，不用来分割语句。
   - 也是因为上面的原因，整个 switch-case 其实是一个作用域。
   - Python 的不是这样的
   - 如果 case 比较少的话没必要用 switch-case
   - 绝大多数情况下，大多数复杂的 switch-case 是因为没设计好
      - 可以用函数的跳转表，这样的好处是有更好的可扩展性，是软编码的
      - 状态机有更好的面向对象的方法
   - C 语言编译出来通常不是使用跳转表的
- 用来控制的循环变量在循环内部能不能被使用
- for ( ; ; ) 这样的可读性不好
   - 我们觉得没有问题因为我们已经读了三年了，习惯了就好了，但是对于初学的人来说，对于从来没有接触过这些东西的人来说，那么可能还是会觉得，这个中间这个灯不开还是太暗了
- Python 的所有循环语句可以跟个 else：正常离开循环的时候执行；因为 break 结束循环的话不执行
- Java 的 break 有标号，可以跳出好几重循环
- 所有的程序都要容器，对于容器上的运算，我们在编程语言层面上能够提供什么样的关注是非常重要的
- Java 和 C++ 引入函数式编程的最终目的是实现流式计算，流式计算是在容器上的计算
- 先学 while(1)，然后再学 while(foo)，然后学别的；刚开始想括号里放什么条件是很困难的
- 单一出口原则：只有一个 `return`
- 如何访问变量呢
   - 全局变量（静态变量）
      - 需要一个 32 位的地址，但是 32 位的指令显然放不下 32 位的地址
      - 那可以把地址放到一个寄存器里
      - 怎么把 32 位的地址存到 32 位的寄存器里呢
      - 把这个地址放在代码里
      - 编译的时候确定了这个地址放在哪里，但是这个地址到底是多少（即这个静态变量到底放在哪里了）在链接的时候才确定，因为静态变量放在 `.data`。
      - ![image.png](./assets/1639053354498-df1265b3-cfdc-40fb-bae2-bfcefab7aa82.png)
      - 所有赋初始值的全局变量的存储空间会连续排放，这些变量的初始值也会在代码的某个部分按相同的结构连续排放；在 main 函数开始前会有一段代码把这块数据搬到存储空间中。因此代码里是看不到全局和 static 变量赋值的编译结果的
   - `auto` 变量就是本地变量
   - 本地变量不需要随时写会内存，如果有可能就不写；唯一可能的情况是要把这个变量的指针传给别人，这时候必须写回防止错误。另外在线程切换或者调用函数的时候也只是吧这个寄存器放到栈里去。
   - 本地变量通过 sp 就很好用了。
- 指针 `a = &b`
   - `b` 是自动变量的话用 sp 偏移就行了
   - `b` 是全局变量的话就去找刚刚说的那个名字的位置
- 数组
   - `int a[4][5][6];`，访问 `a[2][3][4]` 就是 `(2*5+3)*6+4` 个单元
- 如果把一个函数的活动记录放在同一个 block 中的话，可能利于 cache 的 locality，可能对性能有好处。
- 现在的 CPU 的寄存器是一部分 caller 保存，一部分 callee 保存
   - save 的规模越小越好；两边各自实际上只需要保存自己会用到的
- 控制流
   - 把 C 语言中的 if-else 的条件取反以后做跳转，为什么呢：
```markdown
### 从 if (x) {...} else {...} 到 if (x) {...}:

#### 条件不取反
cmp x, #0
bne L1		// 条件不取反，即 x 确实不为 0 则跳转
...			// false (没有)
jmp END		// **这句不能省**
L1:
...			// true
END:
...			// after if

#### 条件取反
cmp x, #0
beq L1		// 条件取反
...			// true
jmp END		// **这个就不用了**
L1:			
...			// false (没有)
END:		// **这个也不用了**
...			// after if

```

   - 也就是只有 if 的时候能省一个 jmp
   - switch 多的时候用查找表
   - while, do-while, for 都编译成判断放在最后面，也就是 do-while 的形式；for 和 while 会先做一个无条件跳转
      - 如果弄成 while 那样就是开局判断，不满足就跳走，结尾无条件跳回；do-while 的话就是只在最后判断，满足才跳回
      - 预测；对于一个循环来说跳转肯定比不跳要多的
   - 以前很多经验之谈到现在都是错的，时代不同了，硬件什么的都发生了变化
   - 现在京沪杭高铁只要四个半小时，有人说民国的时候京沪杭都只要四个小时，怎么做到的？换个京啊，解放前的京是哪个京

**_Lec 7 - 21.11.3_**

---


## 8 Subprogram

- 函数式编程的函数和我们平常写的函数还是不一样的
- 代码复制是设计问题
- 单一入口，调用方挂起 suspended，被调方运行完了以后回到挂起前的地方去
   - 线程也满足后面两个条件
- 无类型语言是指变量没有类型，不是数据没有类型
- C 和 C++ 是唯一的需要把原型和实现分开的语言
- C 的 include / Java 的 import / Python 的 import
   - C 的 include 是怎么做的
      - 这个话筒是一个山寨的……
      - 他不理解原版的厂家不知道为什么要有这根带子
      - 正常的电池盒是要标正负极的
      - 这两节电池我用钥匙都拔不出来
      - 我们这么大规模的教室，每个教室都要有一支这样的话筒，而这样的话筒的供电方式居然是干电池
      - 我们本来完全应该采购使用锂电池的无线话筒，这些桌上都是有电源的，下课的时候插上去就好了
      - 根本不需要在桌上放很多节的干电池，给管理人员也带来了很多工作量
      - 我应该停止讲课，专心挖电池
      - 好 终于挖出来了，接下来的问题是我们今天桌上有没有干电池
      - 所以 当我们做采购的时候不应该是便宜就好的
      - 我活的比较长啊，所以见过很多山寨的东西
      - 美工刀……那些山寨的厂家根本不理解刀尾为什么要是可以拆下来的
      - 做改装之前一定要理解原始的设计的用意是什么
      - 就是把那个代码复制进去
   - Java 是在编译的时候装载那个 class
   - Python 的 import 就是 **在运行时刻** 找到那个源文件，执行；如果那个文件有 `def`，那那个函数就是当前作用域里声明了的
   - 他在看到这个函数的时候要知道这个函数长什么样；Java 做两边扫描可以看到后面定义的函数；C 那时候的计算机的内存不允许它做两遍扫描，只有让程序员手动地把函数的声明写到 .h 里
- 参数
   - 直接访问全局变量；成员变量也可以说类似一种全局变量
   - 全局变量和面向对象有不可调和的矛盾
   - 看看 Swift 和 Kotlin，都是大企业里面严格做出来的
   - 当我们说 PHP 的时候，一定要在后面跟一个后置定语，就是 the best language in the world，如果不这么说的话在一定会在网上被很多人攻击的
   - 大厂出的语言跟这种业余玩家对比有什么不一样的
   - 有没有学 Pascal 的，没有了吧，你们这个年龄没有学 Pascal 的
   - Python 的赋值是语句不是表达式；C 的赋值是表达式的缺点是可以放到运算中让计算存在不确定性
   - Python 3.8 说我们现在有一个新的赋值 `:=`，这个赋值是运算符，现在可以写 C 里 `while ((ch = getchar()) != EOF)` 的东西了，只要用 `:=` 
   - 同一个操作在 Python 中有很多种写法，这在语言的设计中可以说是大忌
   - 所以 Python 虽然很火，这是一种社会文化现象，但是作为一个专业的学者，我们需要有清醒的认识，Python 到底是一个什么地位的语言
   - Python 在 1993 年就出来了，作为一个业余玩家，自己玩玩十来年没有人用，他有两个心态
   - 第一个心态，是不是我缺这个东西，缺那个东西，所以我要不要把这个特性拿进来，把那个特性拿进来
   - 第二个心态，反正没人用，我怎么改也无所谓，我改坏了也不会有人来骂我
   - 比如说它的几个容器类型，要加东西，有的用 add 有的用 append 有的用 insert 有的用 put，这在语言设计上也是大忌
   - 形参 formal para 和实参 actural para 的来源是 Fortran 语言，Fortran 77 以前是引用传参，当时内存很小，还没有栈，当时形参和实参是名实相符的；60 年代以后 algo 说我们可以传值了
   - 到 90 年代美国的教育界就提出我们不要再用这对术语了，这对术语非常毒害我们的初学者
   - 任何一个学科都有一个术语体系，如果这个术语是在这个学科以外是看不到的是很好的
   - 英文的造词使得你学一个新的学科的时候所有的词都是生词，所以从这个角度来说用英语学任何一个学科都会更快
   - 中文的词很多我们是可以猜测它的词义的，但是我们很有可能是猜错的
   - 当然现在告诉你们都已经晚了嗷
   - 为什么很多同学政治学不好，因为这个学科用了很多上个世纪三十四十年代的词，它的意思和我们在日常中的意思是不一样的
   - 比如说老有人批评说把 robust 翻译成鲁棒是很糟糕的事情，问题在于你为什么一定要去想鲁棒这个词和鲁和棒有什么关系，他就是这两个汉字组成的一个词而已
   - 所以形参和实参现在其实就是参数和值的关系
   - C 和 C++ 和 Java 采用的方式是位置绑定，就是我第几个值就绑定在第几个参数上
   - Python 调用的时候可以用名字绑定，这样写的很清楚而且可以以任意的顺序调用。缺点是调用的时候要知道第几个参数是什么名字
      - `sumer(my_length, list=my_array, sum = my_sum)` 
   - 参数的默认值的问题
      - C++ 和 Python 有默认值，Java 没有默认值
      - 默认值的缺点是阅读上比较难过，比如看到只有两个参数就以为有一个只有两个参数的版本
      - C++ 不是少传了值，只是编译器帮你把那个值填上了
         - C++ 编译完的程序和 C 语言编译完的程序是一样的，C++ 所有的变化都是编译的；Python 都是运行的；Java 有的是编译的有的是运行的
```python
def f(i, lst = []):
	lst.append(i)
    return lst
f(0)
f(1)
print(f(2))
```

      - 输出是 `[0, 1, 2]`
```python
def f(i, s = 0):
	s += i
    return s
f(0)
f(1)
print(f(2))
```

      - 输出是 `2` 
      - 对 Python 来说，一个函数是一个对象，默认值是这个函数里的一个变量，这个变量是不可改的；对于第二种情况，每次进来 `s` 都是 0；对于第一种情况，每次进来 `lst` 都 **指向** 原来那个列表；运行时刻会复制一个这个变量出来让你用
         - 第一种情况，运行时的 `lst` 和默认参数 `lst` 都指向同一个列表，因为运行时的 `lst` 是复制出的指针：
            - ![image.png](./assets/1639060866341-9848a077-6542-4235-b310-cc46cd80dbb4.png)
         - 第二种情况，运行中的 `s` 指向的是一个值等于默认参数的 `s` 的值的新的对象：
            - ![image.png](./assets/1639060945262-261115af-2882-4b34-9cfc-1edc3288cf91.png)
         - 为什么所有的类型都是指针但是整数和列表还是有不一样的结果？因为变量分为可变和不可变的两种
            - 数字是不可变的，因此 `i += 1` 不是说 `i` 指向的值 +1，而是 `i` 指向了一个新的对象，这个对象的初始值是 `i + 1`，用 C 语言的话说就是 `i = new Number(i + 1)`。
               - Python 的赋值都是这么做的
            - 列表是可变的，因此 `lst.append(1)` 指向的列表增加了一个东西
      - 一个用途：
```python
lst = [0, 1]
def fib(n):
    if n < len(lst)
    	return lst[n]
    lst.append(fib(n-1) + fib(n-2))
    return lst[n]

风险是不知道 fib(n-1) 和 fib(n-2) 哪个先算

d = {0:0, 1:1}
def fib(n):
    if n not in d:
        d[n] = fib(n - 1) + fib(n - 2)
    return d[n]

**可以改成下面的形式，不污染全局变量**

def fib(n, d = {0:0, 1:1}):
    if n not in d:
        d[n] = fib(n - 1) + fib(n - 2)
    return d[n]
```

   - C 和 Java 的函数的定义不是可执行的；解释性语言的函数定义是一个动作；函数的定义是制造了一个对象，叫 `f`，类型是函数。
   - 不同的传参方式
      - pass-by-value (in)
      - pass-by-result (out)
      - pass-by-value-result (in-out)
      - ![image.png](./assets/1639061909453-b87fdf6a-4930-4968-8f4f-31f98a215a7f.png)
      - [Parameter Passing Mechanisms | 参数传递机制 ](https://www.yuque.com/xianyuxuan/coding/cp_5#FHyVy)
      - wk 先生之前帮 hqm 老师做动画演示 C 语言的执行过程，他先写了一个解释器，用文本说明在哪里画一条线，在哪里写字，然后用 C 语言解释并且画出来
   - 类型检查
      - Python 现在已经可以检查参数了
   - 子程序作为参数
      - 回调函数传的是子程序的地址，也就是函数指针；编译型语言做的就是这种事
      - 解释性语言把函数就按一个值存
      - 闭包
   - 如果那编译语言的角度去想，我们会习惯把我们语言的每一个特性想象成机器语言怎么去执行，但是解释性语言不需要这么想
   - 当我们有了足够的抽象以后，是不是意味着我们有一天能够脱离冯诺依曼
   - 不要老是想着碳基的生命如何在硅基上得到延续，也许我们还要想另一个问题就是硅基的程序如何能够在碳基上得到执行
   - 是 MUA 还是 C 语言更适合在碳基 CPU 上运行

**_Lec 8 - 21.11.10_**

---

- nested subprogram 局部函数
   - 局部函数能不能访问外部函数的变量
   - 在 Java 里，同一个函数内，大括号外面定义过的变量在大括号内是不能重新定义的
      - 顺便说这两天有个大家不一定会关注这个事儿哈，因为你们没到45岁
      - 这两天有个帖子说有个有个人给总理发了一个公开信，说自己45岁了，熟练掌握各种程序员技能是吧，从企业离职了，找不到任何工作，然后给总理发公开信呼吁解决这个问题
      - 然后有人从他的信里面发现，他虽然45岁了，虽然他号称熟练掌握各种技能，但是找不到工作可能是应该的，因为他把 Java 这个词写错了。他写成了 java
      - 说明他一定并不真的爱 Java。对吧，所以连人家名字到底是什么都不知道，因为大写和小写完全是两个不同的概念，而且从英文来说这个单词一定是大写的
   - ![image.png](./assets/1639066054213-f281be69-a11a-440a-ae72-7a142976ddd5.png)
   - Referencing Environment
   - ![image.png](./assets/1639066926680-87eca5f6-a13f-439c-a7c0-105c379f168d.png)
   - ![image.png](./assets/1639066918843-57f4d3d4-4ad3-4a2f-9cdf-e2ac08b35e96.png)
- 重载 Overload
- 泛型 Genetic - 模板
- 要考虑的问题
   - 是否允许副作用
      - I/O 不在讨论范围内
      - 参数都应该是 in-mode，不应有全局、静态，包括类的成员变量
      - 如果有副作用是不可能做到真正的函数式的
   - 允许返回什么样的返回值
      - C 不能返回数组或函数（只能返回函数指针）
      - C++ 还可以返回自定义类型
      - Java 和 C# 可以返回任何类型的对象，但是方法不是对象，不能被返回
      - Python 和 Ruby 把函数也当做正常的对象，因此也可以返回函数
- 协程 Coroutines
   - Coroutine call 也称为 resume，从上次跳出的环境继续运行
   - [https://blog.csdn.net/mieleizhi0522/article/details/82142856/](https://blog.csdn.net/mieleizhi0522/article/details/82142856/)
   - 考虑线程。线程切换的情形：
      - 时间片耗尽，或者中断
      - 主动操作导致的阻塞，例如等待信号量
   - 主动操作导致的阻塞，程序员是知道在哪里会切换走的
   - 线程切换要保存现场，实际上调用函数也差不多，只是调用函数是从函数的开头开始运行的，不需要恢复那个现场
   - 而协程的调用，或者说 resume，其实就是和线程切换做了一样的事
   - 没有用操作系统线程调度的手段实现了线程的交替运行，这样可以减少操作系统的负担
   - 有的时候我们明确知道这里要调度，比如信号量，我们就可以手动让它交替运行
   - 不这么写的好处是程序员简单，但是操作系统是花时间让不那么聪明的人也能在这样的操作系统上写代码
   - 隔 10ms 打断一次；“操作系统噪声”
   - GPU 快除了是因为并行以外，还因为上面是没有操作系统的
- 突然学 Python！
   - 字面量是源代码中直接可见的值
      - 0x10 和 16 是两个相同的值，但是不是两个相同的字面量
      - `"Hello"` 是一个字面量，这两个引号也是这个字面量的组成部分
         - 如果没有这个引号，`Hello` 就表示的是一个变量的名字
   - 常量是不会变化的量，它可能以字面量的形态存在于代码中，也有可能存在在变量中
   - Python 的列表的括号是表达式括号，因此 `[a, b, c+2]` 这里的变量和表达式都会被计算；和 `['a', 'b', 'c+2']` 不一样
   - 但是 MUA 的列表的括号是字面量括号，`[a b c]` 里面的 `a` 就是一个 word，不会被计算
   - `sum([1 / num for num in range(1, 21)])` - 求 1 + 1/2 + ... + 1/20
      - 就一个 sum 为什么还要用别人的
      - 因为也许有一天它的 sum 就会写的比我们更快
   - `sum([1 / i if i % 2 == 1 else -1 / i for i in range (1, 21)])`
   - 不让程序员写循环的好处是，很容易并行展开
   - 生成器不占据内存
      - ![image.png](./assets/1639456934271-b0106a95-9629-4e4c-8382-cbb27e864b10.png)
      - ![image.png](./assets/1639456914345-3f4a4324-e800-4bf3-91b6-24ce8039f160.png)
   - Fibs 协程：![image.png](./assets/1639456950135-94ecfdde-6d66-457a-8a2e-0437acfc2dfa.png)
      - 这里 fibs() 返回的是一个生成器
   - 生成器其实只是记录了规则，真正使用这个生成器的时候才会做动作
      - 里面每生成一个就会 yield 一次（之前写的其他生成器也是这样）；我们的 `for i in fibs()` 其实就是 `i = fibs().next()`
      - 如果生成器没有下一个 yield 的话会抛出 StopIteration 异常，但是 for 本身处理了没有下一个的情况
   - ![image.png](./assets/1639457615529-abdaa8e7-6c9c-4772-bb8d-0efa15020de1.png)
      - 阻塞，等 send()。第一次 send 一个 None 启动。send() 自带 next()
   - ![image.png](./assets/1639457712402-ff7d535a-c0f8-4c26-9b2b-908a09617d62.png)
      - close 可以关闭。再 send 就不可以了，抛异常

**_Lec 9 - 21.11.17_**

---

- ![image.png](./assets/1639493503734-14b4f59f-2645-488d-954f-2ff2afa90061.png)
   - Python 可以返回多个值；其实是一个糖，返回的是一个 tuple
   - ![image.png](./assets/1639493875276-16941b1f-e534-4888-9f11-fd5087557435.png)
   - ![image.png](./assets/1639493907165-7f4e7255-de4b-4abb-9b1f-2c3a85854b78.png)
- Subprogram 的实现
   - Activation Record 存储是静态的；没有堆栈
      - 在第一代 Fortran 的时候，计算机还不能间接寻址，即不能根据寄存器的值进行寻址，因此 sp / bp(fp) 实现不了，自然不能有堆栈
      - 每个函数只能被调用 1 次
   - Stack-Dynamic Local Variables
      - 支持递归了
      - 寄存器是 caller 存还是 callee 存由谁决定呢？compiler / language / chip (machine, ISA)？
         - 是 chip 决定：binary interface protocol：二进制接口上的兼容性
         - 为了实现不同编程语言之间的函数调用，同种 ISA 上不同语言应该采用同样的规范
      - AR 的大小也是编译时已知的
      - Clang 把 Local 的数组放到最上面去，gcc 就怎么定义怎么来
      - base pointer / frame pointer / dynamic link。For what:
         - 编译时不可知的栈空间使用。例如，C 语言支持 `alloca` 在**栈上**分配空间；或者可变长度的参数
         - 在函数内部如果会有栈的调整，那么用 sp 寻址显然不如 bp 好，因为算的更加麻烦了
         - 方便 debug。可以根据 bp 容易地跟踪所有的函数调用
         - 对于 `[sp+4]`, `[bp-4]` 这样的寻址方式，偏移量的大小是有限的。如果结合使用 sp 和 bp 可以增加总共能够访问的范围
         - Ref: [https://stackoverflow.com/questions/46797915/what-are-the-advantages-of-a-frame-pointer](https://stackoverflow.com/questions/46797915/what-are-the-advantages-of-a-frame-pointer)
      - 返回值存哪呢？如果放在栈里的话应该在 bp 之前推进去一个空格之后存返回值用；因为 bp 后面推进去的是参数和 callee 的 local，出来的时候都会 pop 掉的。
         - 所以其实可以认为有一个 hidden parameter (out mode) 用来存返回值~
   - Nested Subprogram
      - 子程序嵌套，访问外面的本地变量
      - 插一句：为什么要用堆栈存 AR 呢？
         - 因为函数调用恰好也是一个 FILO 的过程。
         - 但是，当有多个线程的时候，要给每个线程预留一个 stack 的空间。所以会有 internal fragment / stack overflow。
            - “构成了 C 语言运行安全的主要隐患”
            - 怎么解决呢？首先需要考虑到，实际上 caller 和 callee 的 AR 并没有必要挨在一起。可以考虑 caller 在堆里开一段空间存 AR，这样就没有 fragment 了。
               - 问题是，如何知道多大呢？Linker 肯定知道多大
               - 这种方法一些值得讨论的问题。这种方法使得调用函数的开销变大了；尤其是 `malloc` 和 `free` 本身是不可重入的，因此在多线程时性能问题会更加突出。
               - 这个问题的解决可以考虑将 `malloc` 和 `free` 做成系统调用。
               - 另外，`malloc` 和 `free` 是在堆上做操作；现在的堆是用链表实现的，每次需要遍历链表直到找到一块能用的够大的内存。因此在堆很空的时候 `malloc` 会很快；但是堆很满的时候会很慢。因此，对于实时系统，我们要求每个函数的调用时间都是可预期的，但是 `malloc` 的存在可能会违反这个问题。
                  - 我们看到图里画的堆都是往上长的，其实并不是像栈那样分配一块空间就长一点；而是 `malloc` 发现没有地方可以分配的时候会问操作系统再要一块，这个才是长的过程。
               - 因此，为了解决这个问题可以考虑把堆用数组的样子实现，这样分配的速度就更有保障了。
            - 另外一个解决思路就是在每次用栈的时候检查当前栈空间是否用完；甚至可以考虑策略在发现用完的时候想办法恢复。
            - 总之，上述讨论实际上都是用运行时间去换取运行的安全性。

**_Lec 10 - 21.11.24_**

---


## 9 Abstract Data Type / OOP

- 一开始序号不要叫 1 2 3 4 5，叫 10 20 30 40 50，这样如果有个东西想放在 40 和 50 中间的时候就可以叫它 45。
- “我又在换电池了”
- Parameterized ADTs / Generic Classes 泛型
   - 继承是为了重用
   - C++ 刚开始设计的时候没有单根结构，也就是没有一个公共父类（比如 Java / Smalltalk 里的 Object）
   - 有单根结构的话容器就很好做了，没有单根容器就很难搞
   - 没有单根结构也有个好处；因为有单根结构的话任何一个程序都不能脱离标准库而存在（比如 Java 的 Object 类以及它调用的那些类），但是 C++ 的标准库是可以不要的
   - 因此它设计了多继承，这样容器就行了
   - 多继承引发了 diamond inheritance 菱形继承
   - 为了解决这个问题，它提出了虚继承
   - C++ 提出了另一个方案，就是模板
   - 刚开始 Java 看不起模板：“一个只能放钢笔的笔袋”
   - 后来 2004 年左右，有人发现模板不仅仅是解决容器问题；template 提出了一种新的编程的范式：泛型
   - 泛型是和 OOP 是两个在编程语言上不同的发展方向
   - 结构化程序设计：70 年代；70 年代末 80 年代初开始被广泛认知
      - “结构”就是顺序、分支、循环
      - 一个函数内部，代码是以语句块呈现的，而不是以单条代码呈现的
      - 这个就不是结构化的语言：![image.png](./assets/1639572350148-9b70c955-bf39-4fbe-abcf-e94897d06bde.png)
      - 这里就只有 4 个语句 ![image.png](./assets/1639572373770-2043ee3c-f069-45a5-9b54-6afc5420bca3.png)
   - 90 年代开始广泛认识 OOP
   - 最近这三十多年有三个潮流，但是都没能把 OOP 赶走：
      - 软件构件模型 
         - JavaBean 之类的；是为了向后兼容
         - 也为了可以不用写代码而是用构件就能编程，这也是一种复用。
         - 每个部分都是独立的，运行的时候动态链接
         - 所以其实可以每个部分单独替换
      - Template / meta-code
         - 模板制造元代码，在静态的代码之上的元复用
         - 制造代码的代码
         - 后来 Java 也有泛型了
      - 函数式
         - “甚嚣尘上”
- Python 的 OOP
   - Python 的对象就是一个 HashTable；或者用 Python 自己的话说，一个字典
   - Python 作为一个动态语言，赋值之前并不需要有声明。因此在 `_init_` 中进行的 `self.name = name` 这样的赋值其实就是在这个 HashTable 中添加一个项
   - 因此，不同的 `_init_` 可以生成具有不同成员变量的类实例
   - Python 也可以在 class 级声明一些变量；但是这些变量就是类变量，也就是 C++ 中的静态成员变量
   - C++ 和 Java 调用成员函数都有一个隐含的参数 `this`，但是 Python 的成员函数定义就有一个显式的 `self`；如果没有 `self` 就是静态函数
   - Python 的私有变量是在变量前面加 `__`，即 `name` -> `__name`
      - 但实际上它只是把这个变量的名字改成了 `_ClassName__name`，例如这个类叫 `Student`，那这个变量就被改名为 `_Student__name`。
      - 如果在外部访问 `__name` 会告诉你没有这个变量；但是如果访问 `_Student__name` 就能访问到这个“私有”变量
- JS 的 OOP
   - JS 甚至没有 class
   - 创建对象用 `var o = new Object();` 或者 `var ciclr = {x:0, y:0, radius:2};`
   - 很容易看得出来其实就是个字典
   - 删除：`delete ciclr.x;` 或者 `ciclr.x = null;` 
   - 遍历 `for (var x in o)`
   - ![image.png](./assets/1639573772064-a585e439-7fe8-4995-9d62-0e15cfadeb76.png)
   - Prototype 原型
      - ![image.png](./assets/1639573933930-919d3588-0a44-4182-9e2b-e65e3f2e982b.png)
      - 访问成员变量值的时候，先查自己这个对象的字典里有没有；没有的话再去类的 Prototype 里找。
      - 如果做了 `person1.name = "xyx";`，并不是改了 Prototype，因为 Prototype 本身没有复制一份到这个对象的字典里；只是现在真正地把 `name` 这个成员加入到了这个对象的字典里，因此我们再读取 `person1.name` 的时候会优先访问到 `"xyx"`。
      - ![image.png](./assets/1639574126884-c14acd36-8e62-4a35-ac82-a5e6b1549c77.png)
      - ![image.png](./assets/1639574136605-2bb52808-ec68-4c1c-aab7-a381835a8cff.png)
- 关于 OOP 的一些讨论
   - The Exclusivity of Objects
      - a. 所有东西都是对象
         - Java 就没有做到这一点
         - 优点：优雅纯洁
         - 缺点：对于简单数据比较慢
      - b. 把对象加到现有的类型系统中
         - 优点：在简单的数据及其运算比较快
         - 缺点：对不同类型的东西做的事情不一样
         - C++ 有模板，模板可以放基础类型
         - Java 的模板只能放对象，或者说对象的指针。因此 Java 有包裹，对应着每一种简单类型
      - c. Include an imperative-style typing system for primitives but make everything else objects
         - 没看懂
         - Adv.--fast operations on simple objects and a relatively small typing system
         - Disadv.--still some confusion because of the two type systems
   - Are Subclasses Subtypes?
      - 子类对象是不是能在所有父类对象可以被使用的地方被使用？
         - 如果是，那么就会有一些限制，比如 override 的函数不能和原来的函数有类型冲突
   - Type checking & Polymorphism
      - 多态需要动态类型检查。
         - 动态类型检查是 costly 的，而且会延迟 error detection
      - 强类型还是弱类型？
         - 强类型可以尽早静态地检查出一些问题
   - override 函数，默认静态 / 动态绑定？
      - 静态绑定可以提高效率
      - 动态绑定更 OOP

**_Lec 11 - 21.12.1_**

---


## 10 JVM

- `.class` 加载到 JVM 后翻译成本地代码再运行很美好，但是有多少情况下我们需要到处运行呢？
- 虚拟机
   - 模拟器
      - 完整指令集架构虚拟机 (QEMU)  - 模拟 CPU 运行，比如电脑上模拟红白机
      - 应用程序二进制接口虚拟机 (Rosetta) - 在同一个机器架构上，但是运行不同操作系统的程序
   - 语言运行时
      - 虚拟 ISA 虚拟机 (JVM) - 有自己的一套 ISA；可能会做一些语言相关的工作
      - 语言虚拟机 (Lisp, JS) - 解释器之类的
- 虚拟机核心组件
   - 加载器和动态链接器
      - 加载：将代码加载到内存中
      - 链接：`f() { ... g(); ...}` 的汇编就是 `call <address of g()>`。将 `g()` 的实际地址填进去就是链接。
         - 在运行之前做就是静态链接，和编译一起做，例如 C 和 C++；当然它们也有动态链接
         - 在运行开始后做就是动态链接，例如 Java 的方法都是动态链接的。Python 当然是动态链接的
   - 执行引擎
      - 最深就是 QEMU 那样模拟 CPU 节拍；最浅就是解释器那样的
   - 内存管理器 / 线程调度器 / 语言扩展 
- ![image.png](./assets/1639583621723-8e129edb-c24d-46a9-a13d-10b7684393a9.png)
- ![image.png](./assets/1639583656085-7f1c61a6-7ada-4667-8199-8004890ac9a7.png)
- ![image.png](./assets/1639583672877-1c485675-ac5b-4bfc-96d5-862d870d5677.png)
- Class Loader 把类加载进来。有默认的 Class Loader，用户也可以自己写，只需要实现 java.lang.ClassLoader ，从而满足一些从奇怪的地方或者网络找 Class，或者以某种特殊方式解密 Class 等等的要求
- JVM 记录每个类是用哪个 Class Loader 弄进来的。默认来说，每个类只能看到和它用同一个 Class Loader 加载的类
- 一些 tradeoffs
   - 早期 JVM 解释字节码 `.class` 并运行，比本地运行慢 10~30 倍
   - 后来引入了 JIT (Just-in-Time) 即时编译技术，将 `.class` 中的字节码或其中部分代码编译成本地代码再运行，这样会比解释执行快 7~10 倍，但是还是没有本地运行快
   - Java 程序都是动态链接的
   - 所有的数组访问都会检查下标是否越界
   - 所有的对象都在堆上建立
   - 所有的对象引用都会在运行时检查是否为 null
   - 垃圾回收
   - 基本类型在所有平台上的位数都是一样的
   - 字符串都是 UNICODE
- “我并没有教大家要去开个公司和姥姥的公司对抗嗷”
- 每个 JVM instance 在一个 Java 应用程序开始时产生，在应用程序完成时结束。
- 每个 JVM instance 都有一个各线程共用的 method area 和 heap。当 JVM load 一个 .class 的时候（实际上，在使用时才会被加载），它解析之并放在 method area；当一个对象产生时，它被 method area 中的对应数据实例化并被放置在 heap 中。
   - ![image.png](./assets/1639910716391-faff463d-c25e-4312-927a-2bbb0c7cc792.png)
- 程序并不能直接访问 method area，但是对于每一个加载到 method area 中的 class data，heap 中有一个 java.lang.Class 类的对象代表它。当然，heap 中也有一个 java.lang.Class 的对象代表 java.lang.Class 类。
   - ![image.png](./assets/1639915056589-64451d0d-40e1-4ac4-80e3-9ebbde4a44c0.png)
   - ![image.png](./assets/1639915096578-de5287ad-dd12-47d4-b61d-1ff9a62e4d86.png)
- **每个**线程都有一个 PC 和一个 Java stack；如果这个线程正在执行 Java 函数，那 PC 就指向下一条指令，栈里是参数、局部变量、返回值和运算的中间结果（并没有寄存器，数据都在 operand stack。编译时期 operand stack 和 method stack 的大小都是已知的，所以会放在 .class 里）
- JVM 有一个共用的本地函数栈
- ![image.png](./assets/1639913559221-cc64e768-2abf-407a-89c0-f99d9c29915a.png)
- final 变量都在 method area 作为常量保存
- 本来常量池中一个类的 ref 存的是这个类的名字（symbolic reference）；这个类 load 进来以后替换成指向这个类的指针（direct reference）。这个过程叫做 constant pool resolution
- ![image.png](./assets/1639918683644-b02021df-373a-474c-9c8a-eebcc598b1d6.png)
- ![image.png](./assets/1639920739220-33069d37-881b-4044-b990-dd9a35778845.png)
   - 从语言层面上限制了只能访问本地内存
- Java stack 中有 frame data 部分，其中包含了指向常量池的指针。当运行到需要使用常量池中项目的指令时，JVM 会使用这个指针来进行访问。
   - JVM 访问时如果发现 reference 仍然是 symbolic 的话，它就会暂停运行，去做 resolve，也就是 dynamic link。

**_Lec 12 - 21.12.8_**

---


## 11 Functional Programming

- 第一个实现自动内存管理的语言是 LISP (1950s)
-  ![image.png](./assets/1640181426867-c40ab69a-1414-4f1b-b606-f64420096c1f.png)
- 面向对象的复用是大粒度的
   - 面向对象把操作放在循环内部完成，在一次循环内完成任务
- 函数式方便我们在更细小的层面上进行复用
   - 把程序描述为表达式和变换
- ![image.png](./assets/1640182427988-4fdb0f9a-0e9b-4e7a-9210-4f46fc1dd85a.png)
   - ![image.png](./assets/1640182459689-d037dd26-2baf-48f3-ad45-3be5e7e58ac9.png)
   - ![image.png](./assets/1640182578998-013c98f4-5b75-42f0-b03a-bfb92388586a.png)
   - 并行：![image.png](./assets/1640182550943-e683941f-033e-4152-a8e9-a57c3a5a5c69.png)
- filter 是 lazy 的，sum 是 eager 的，即真正用到这些数据的时候才会用 filter，有点像之前讲的生成器
- lambda 对一个输入类型给出一个输出 `lambda x . body` 即 `x -> body` 
   - 绑定标识符就是作为输入的标识符。例如 `y -> x -> plus(x, y)` 中，x 是绑定标识符，plus 是自由标识符，y 在内层是自由的，在外层是绑定的
   - 运算法则
      - alpha-转换：变量名不重要
      - beta-规约：应用 lambda 表达式时，在不引起绑定标识符和自由标识符之间的任何冲突的情况下，可以用参数值对 lambda 演算中对应的标识符相关的部分做替换，替换方法是把标识符用参数值替换：`(lambda x . x + 1) 3` 即为 3 + 1 = 4
      - eta-规约：两个 lambda 算子对于相同输入产生相同输出，则可以相互规约
- 函数式编程
   - 和面向对象、过程式并列
   - 函数是一等公民
   - 强调将计算过程分解成可复用的函数
   - 函数应该是纯的、没有副作用的
   - 相同的输入永远获得相同的输出（因此可以记忆）
   - 合成和柯里化
      - ![image.png](./assets/1640184955172-d1f6ddcb-a8e2-40c3-8593-06ef1505c192.png)
         - 合成有结合律
      - 柯里化：将一个多参数的函数转换为单参数函数
         - ![image.png](./assets/1640185083849-11401807-29d3-47e0-81d1-8ddc30d5e416.png)
   - 纯函数式语言中的变量是值的名字，而不是存储状态的单元
   - 变量的值是不可变的
   - 所有的运算都产生新的值，不修改原来的值
   - 函数式程序表明计算结构而不是计算过程，因此适合惰性计算
   - 函数式编程的函数都是不可重入的，因此适合并行计算
   - 由于变量不可变，因此无法实现循环，只能用递归
      - 循环告诉程序“怎么做”，递归告诉程序“做什么”，因此递归更适合函数式编程的思想
   - 随着硬件能力的提高，把越来越多的任务让渡给语言和运行时
   - 闭包
- 流计算是函数式编程的典型应用
   - 基本构造单元：
      - filter
      - map
      - fold / reduce (E.g. sum, count, any...) : 把一个容器降维成一个标量


**_Lec 13 - 21.12.15_**

---


## 12 并行编程

- 并行机
   - SIMD, Single Instruction Multiple Data, 在一条指令中包含多个数据从而实现同时计算
   - 多核 / 多机
   - 异构：GPU (有点像 SIMD) / FPGA
- ![image.png](./assets/1640265941804-0f6dfff7-6efa-41e9-aa6e-57d2a048c120.png)
- ![image.png](./assets/1640266199241-a0467e6f-60e8-4c9d-a6f6-2a0f720f9b30.png)
- ![image.png](./assets/1640266212754-1ffe5b2f-beb8-470e-bb15-794fae8167a7.png)

**_Lec 14 - 21.12.22_**

---

- 并行：新建一个线程，或者用更抽象的语言表达
   - <br />

**_Lec 15 - 21.12.29_**

---


## 13 Programming in MUA

- ![image.png](./assets/1640875464135-39047eb1-4ce6-4477-90f3-1c9a07da6f4e.png)

## END OF FILE
