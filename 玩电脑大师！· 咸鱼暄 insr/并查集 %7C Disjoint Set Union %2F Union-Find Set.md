

### 什么是并查集
并查集是一种树形的数据结构，解决的是无向图的动态连通性问题（[什么是连通性](https://www.yuque.com/xianyuxuan/coding/tiympp#eMLtK)）。课本上描述其解决的是动态等价性问题（[等价关系和等价类](https://www.yuque.com/xianyuxuan/coding/lfxqyr#tibwO)），这两种问题基本是等同的。<br />并查集将在同一个连通分量的节点连接在同一个树上，每一个树用其根节点表征。即，每个连通分量的节点构成了一个集合。<br />当我们判定两个节点是否处于同一个连通分量（同一棵树上）时，只需判断其是否有共同的祖先。<br />当我们需要将两个连通分量连接起来时，只需将一棵树的祖先变成另一棵树的子节点即可。


### 并查集的实现
并查集主要实现两个功能：

   - **合并** (Union)：将两个子集合并为一个集合；
   - **查找** (Find)：确定某一个节点属于哪个子集。

我们只需维护一个 `father` 数组， `father[i]` 是节点 `i` 的某一层父节点。我们规定根节点的父节点为它自己。<br />参考代码：
```c
int father[MAXN + 5];

/* 初始化 */
for(int i = 0; i < MAXN; i++)
    father[i] = i;
/* 在没有进行过合成时，每一个节点都是一个独立的连通分量，即每个节点都是根节点 */

/* 查找函数：递归地访问父节点，直至访问到祖先返回 */
int findFather(int x){
    if(father[x] == x) return x;
    else return father[x] = findFather(father[x]);
    /* 路径压缩。将查找路径上访问到的点的父节点直接设为根节点，减少此后访问次数 */
}

/* 合并函数：将一个集合的根节点的父节点设为另一个集合的根节点 */
int merge(int x, int y){
    father[findFather(x)] = findFather(y);
    /* 如果两个节点本就属于同一集合，仍然适用。原因是显然的 */
}
```
上述代码中的第 11 行，我们采用了 **路径压缩**（path-compression）算法。

显然，在合并中将一个简单的树并到复杂的树下方而不是相反，是一种更加明智的做法。因此，我们可以在合并中增加一个判断，将结点数或深度较小的树合并到较大的树下面。我们称之为 **启发式合并** 或 **按秩合并** 。这种合并方式可以降低最坏时间复杂度，但同时需要额外的空间来记录子集的秩。

由于我们在 `father[]` 数组中将根节点的值储存为自己，而且每次合并时均是对两个根节点的操作，因此我们可以考虑用根节点来保存树的结点数或深度。为了与非根节点区分，我们将它们存成结点数或深度的相反数。如下图所示，两个数组分别是 **按大小合并** (Union-by-size) 和 **按高度合并** (Union-by-height) 中的 `father[]` 数组。1, 2, 3, 5 是根节点，因此它们保存的是所在树的大小 / 高度的相反数；4, 6, 7, 8 不是根节点，因此它们保存的是它们的父亲节点。

![image.png](./assets/1606282731424-9e6e4b08-e9a1-4ba2-b92d-38ade9743914.png)
这些算法的代码实现是简单的，此略。

![_EOF.png](./assets/1606282863100-66204d84-35bc-407a-a4c2-1902829a2568.png)
