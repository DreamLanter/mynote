---


### 写在前面

:::warning
本文的目标是：

   - 帮助读者快速掌握 **初步看懂汇编语言代码** 的能力，从而帮助解决平常** C 语言编程 **中的一些疑惑；
   - 给读者指引进一步学习的方向。

本文 **不涉及** 的内容包括但不限于：

   - 汇编语言是如何实现运行的；
   - 汇编语言是如何变成机器语言的；
   - 涉及 I/O、系统调用、中断等虽然在 LC-3 汇编介绍范围内，但与 **目标** 关系不大的；
   - 等等。
:::

:::danger
**如果您在阅读过程中的任何一个步骤出现了卡顿、不理解等问题，或者发现了文中的错误，又或者对文章内容有意见建议，请务必在评论区进行评论或者与我联系，以便我更好地完善知识体系和结构**。**非常感谢！**<br />**如果可以，请反馈给我各部分或总体的阅读体验和用时，帮助我进一步改善~**
:::

:::success
文件末尾有课本的电子版。
:::

众所周知，计算机能 **直接 **识别和执行的指令是由一组有意义的二进制代码组成的。这种指令的集合被我们称为 **机器语言 (Machine Language)**。但是，机器语言的直观性差、难以学习和纠错，且 **严重依赖具体的计算机架构**，因此它是低级的语言。但同样也因为其简单和纯粹的特性，它也具有高效率和高速度的特点。<br />人们认识到机器语言的这些问题，于是使用了一些有意义的助记符来与机器语言进行一一对应，从而更加便于阅读和书写。这就是 **汇编语言 (Assembly Language)**。它只是和机器指令的一一对应，并没有改善机器语言的思维方式与直观思维不同的问题，且同样不便于移植。汇编语言同时保留了机器语言高效率、高速度的特点。

LC-3 (Little Computer 3) 是《计算机系统概论》一书设计的一种简单计算机，用于介绍计算机的底层机制。LC-3 的指令集相当简单，但是理解 LC-3 指令集后就可以掌握汇编或者说机器语言的理念，从而能非常方便地理解其他架构上的汇编语言。因此本文选择它来完成后续的讨论。<br />本文旨在 _速成_，因此省略了一切不必要的概念，核心目标是为了快速掌握 **看懂汇编语言的能力**。

本文预设读者具有一定的计算机和 C 语言基础。<br />本文使用的参考书目是《计算机系统概论》（第二版）。


### 从一个例子开始！

#### 内存和寄存器
众所周知，计算机是有存储功能的；本文中会讨论到的只有 **内存** 和 **寄存器**。<br />**寄存器** 能够存储二进制数码，LC-3 的寄存器的宽度是 16-bit 的，这表示一个寄存器能够存储一个 16 位的二进制数。在 LC-3 中，通用寄存器有 R0~R7 这 8 个，其他寄存器的功能我们不去理解。我们只需要知道 R0~R7 代表着 8 个能存数据的地方。LC-3 还有若干专用寄存器，用来帮助程序运行，需要使用时再做讨论。<br />**内存** 就像一个长长的数组（这个比喻实际上并不恰当，但是方便理解），这个数组的每一项有一个固定的位数，我们说的 32 位系统的每一个内存单元就是 32 位。内存单元是有序号的，这个序号是线性排列的，我们可以根据序号取得对应内存单元上的数据。在 LC-3 中每个内存单元是 16 位的，总共有 216 个内存单元，因此其序号是 0 ~ 216 - 1，可以用一个 16 位二进制数表示。

从一个例子开始！
```
; CODE 1
 .ORIG x3000
 AND R0, R0, #0		; R0 = R0 & 0
 ADD R1, R0, #1		; R1 = R0 + 1
 ADD R2, R1, R1		; R2 = R1 + R1
 NOT R3, R2				; R3 = ~R2
 HALT
 .END
```
	同一行中，分号 `;` 及其后面的内容表示注释，不影响运行结果。与 C 语言等一样，LC-3 汇编中的空白符个数不影响运行结果。

这个例子展示了 LC-3 支持的 **全部** 算术运算，包括 `AND`, `ADD` 和 `NOT`。实际上现代使用的架构支持很多更复杂的算术运算。<br />第 1, 6, 7 行可以理解为 LC-3 程序的基本结构。

   - 第 1 行的 `.ORIG` 是一个 **伪操作**，即它是为了提示汇编器（将汇编代码汇编成机器码的工具）将程序放在内存的什么位置，伪操作并不会出现在最终的机器码中；
   - 第 6 行的 `HALT` 表示程序停止运行；
   - 第 7 行的 `.END` 也是一个伪操作，表示汇编代码结束了。出现在此后的任何字符都会被汇编器丢弃。请注意：`HALT` 并非伪操作，是会被翻译成机器码的，是为了提示计算机程序运行结束并退出；而 `.END` 则是为了告知汇编器代码结束；这两者是不同的。


#### 算术运算
第 2 行使用的是按位与运算 `AND`，表示将寄存器 `R0` 中的值和立即数 `0`（`#` 用于标识立即数）做与运算，将结果存入 `R0` 中；也就是 C 语言中的 `R0 = R0 & 0`。这一行实现的功能实际上就是 `R0 = 0`。<br />`AND` 运算支持的格式是 `AND DR, SR1, SR2` 和 `AND DR, SR, #imm5` 两种。其中 `DR` 表示目的寄存器 Destination Register，`SR` 表示源寄存器 Source Register，`#imm5` 表示 5 位有符号立即数 immediate。<br />加法运算 `ADD` 同样只支持这两种格式，第 3 行和第 4 行展示的就是这两种格式的使用。其对应的 C 语言代码已经在行末进行了注释。<br />按位取反运算 `NOT` 的格式更加简单，是 `NOT DR, SR`，含义是显然的。<br />（请考虑，如何使用这些指令做减法呢？）


#### 尝试运行！
我们在 [LC-3 Simulator](https://wchargin.com/lc3web/#) 中可以进行该程序的运行。步骤是：
![image.png](./assets/1639070585257-4f8dbbcb-7fe7-4f61-b7e7-b17fb787775e.png)
![image.png](./assets/1639070617072-1e4268c6-114e-44c5-a826-c32de848a06e.png)
![image.png](./assets/1639070630846-c9e1b165-9c0f-47d1-aa1b-c87a841307b3.png)
![image.png](./assets/1639070768411-a62d35ca-fc1e-4cf2-b0be-7d8bccfc8ae3.png)
为什么我们的代码会被装载到内存中呢？实际上，我们现在的计算机采用的都是冯 · 诺依曼架构，这种架构的核心就是代码和数据都以比特流（二进制数码）的形式存储在内存上。只有在内存上的代码才能被计算机运行。<br />内存中的 Hex 列就是对应内存地址上的值；例如内存 `x3000`（表示 0x3000 号内存单元）中的值是 `x5020`，这就是 `AND R0, R0, #0` 对应的机器码。可以看到，LC-3 的每条指令都占 1 个内存空间的大小，即 16 bits。<br />代码开头放在 `x3000` 是因为我们写的 `.ORIG x3000`。<br />Status 部分展示了寄存器的值。PC, IR, PSR 和 CC 就是我们所说的专用寄存器。
![image.png](./assets/1639070839996-ff3febe0-4479-48a7-bd8c-2d20442e25dd.png)
HALT 实现的是停机操作。我们暂时不关心 HALT 做了什么。如果已经 HALT，按 Unhalt 可以恢复非停机状态。<br />按 Reset all registers 可以回到程序开始的位置。<br />如果认真观察可能会看到，PC 的值是即将运行的指令在内存中的地址，而 IR 的值始终是刚刚运行的那条指令的机器码。事实上，CPU 就是通过 PC (Program Counter) 来指示下一条指令所在的地址，从中取得要执行的代码放入 IR (Instruction Register) 中进行运行的。专用寄存器的值不能用算术运算操作来改变。


### 控制流
回想自己的编程经历，实际上我们做的事情无非两种：对变量作算术运算，或者使用分支、循环等结构改变运算的顺序。我们在前一节中完成了基本的算术运算的讨论，下面我们来讨论如何改变运算的顺序。

#### BR 操作
```
; CODE 2
		.ORIG x3000
		AND	R0, R0, #0		;	R0 = 0
L		ADD R0, R0, #1		;	R0 += 1
		ADD R1, R0, #-5		;	R1 = R0 - 5
		BRn	L							;	if (last_result < 0)  goto L
		HALT
		.END
```
	看上面这段代码。值得注意的有 2 点：

- 第 3 行开头有一个 L。这个 L 是我们给第 3 行代码起的一个 **标号 (Label)**，LC-3 中可以使用不重复的字符串作为标号，不区分大小写。
   - 至此，我们看到了一条汇编语句的完整格式：`LABEL OPERATOR OPERANDS ; COMMENTS`，其中 LABEL 和 COMMENTS 是可选的。
- 第 5 行的 `BRn L` 的意思是：如果 **上一次算术运算或 load 运算（稍后讨论）写入通用寄存器** 的结果为负（这里的 `n` 表示负 negative），那么跳转（`BR`, Branch）到标号 `L` 的那句指令运行，否则就运行下一行（第 6 行）。
   - 类似地，还有 `BRz` 表示上一次结果为 0，`BRp` 表示上一次的结果为正，`BRnp` 表示上一次的结果为负**或**正，以及 `BRzp`, `BRnz` 与之类似。`BRnzp` 或 `BR` （这两者机器码完全一样，只是提供了两种可选的助记符）表示无条件跳转。
   - 在这里，上一次写入通用寄存器其实就是 `ADD R1, R0, #-5`，即 `R1 = R0 - 5`。实际上这段代码实现的效果是 `R0 = 0; do { R0++; } while (R0 < 5);`。

请自行在 LC-3 模拟器上运行这段代码。如果认真观察的话，可以发现 Status 中名为 CC 的寄存器会在 N, Z, P 之间改变；实际上这就是 `BR` 操作的原理。CC 是 Condition Codes 的缩写，是 3 个 1-bit 的寄存器，分别是 N, Z, P；在一次算术或 load 运算写入通用寄存器的操作过程中，CC 会根据这次过程的结果改变它的值，每次有且仅有其中一个的取值会是 1。遇到 `BR` 操作时，CPU 检查条件与对应的 CC 是否匹配，决定是否跳转。

请思考：如何实现 while 语句呢？下面这段代码的作用是什么？
```
; CODE 3
	  .ORIG x3000
    AND R1, R1, #0
    ADD	R0, R0, #0
    BRp POS
    ADD R1, R1, #1
    BR	FIN
POS ADD R1, R1, #-1
FIN ADD R0, R1, R0
    HALT
    .END
```

标号的原理其实是，在汇编过程中（请回顾，汇编过程是在做什么？），汇编器会算出 PC 和标号之间的偏移量（即地址差了多少，可能是正的或负的），这个偏移量是作为 `#imm9` （有符号 9 位二进制数）存储在指令中的；也就是说，`BR` 的跳转范围并不能覆盖 LC-3 的整个地址空间。<br />这样我们就能理解，`BR` 操作的实际格式是 `BR #imm9`。

为了实现获得某个标号的绝对地址，LC-3 提供了指令 `LEA`, Load Effective Address，其格式为 `LEA DR, #imm9`，效果是 `DR = PC + #imm9`，即，将基于 PC 偏移的 #imm9 加上 PC 后存入 DR 中。这一过程是改变 CC 的。


#### JMP 操作
我们之前讨论过，LC-3 的地址编号为 16 位；一个 16 位的机器指令中不可能存下这么长的地址，因此我们需要借助寄存器来实现覆盖全局的跳转。LC-3 中提供了 `JMP` 指令，格式是 `JMP BaseR`，无条件跳转到 `BaseR` （R0~R7）中内容指定的地址。


### 内存操作
考虑这些场景：

   - 我们之前说过，CPU 从 PC 所指的位置获取指令放到 IR 并运行，说明 CPU 具有从内存拿数据的能力；
   - `AND` 和 `ADD` 只支持 5 位有符号立即数，如果想要使用更大的数怎么办？
   - 我们的通用寄存器只有 8 个（在后面的讨论中我们会发现，即使这 8 个也并不都能被我们自由使用），如果我有更多的变量怎么办？

内存操作解决您的烦恼！


#### LD 和 ST - PC 相对寻址
如果我们将 code 2 中的 #-5 改为 #-200，就会因为超出范围而报错：
![image.png](./assets/1639075147259-e6a76daa-4683-44af-be8f-1f8af7b88d16.png)
我们尝试这样的代码：
```
; code 4
			.ORIG x3000
      AND	R0, R0, #0		;	R0 = 0
      LD	R2, DATA
L			ADD R0, R0, #1		;	R0 += 1
      ADD R1, R0, R2		;	R1 = R0 - 5
      BRn	L				;	if (last_result < 0)  goto L
      HALT
DATA	.FILL #-200
			.END
		
```
可以看到，运行完 `LD R2, DATA` 后，R2 的值变为了 -200：
![image.png](./assets/1639075255702-031b8ab0-b975-45e7-97f0-91a155d89722.png)
`LD` 即 Load，格式是 `LD DR, #imm9`，（回顾 BR 操作，#imm9 和标号是什么关系？）表示从 PC 偏移 #imm9 处的内存中读取值放入 `DR` 即目标寄存器。即，`DR = mem[#imm9]`。请注意，这个操作也会改变通用寄存器的值，因此也会影响 CC（请回顾 CC 是什么）。<br />对应地，还有 `ST` 即 Store，`ST SR, #imm9` 实现将寄存器中的值写入内存的指定位置。

`.FILL` 也是一个伪操作（请回顾之前提到的两个伪操作），用于告诉汇编器，我要占用这块地址并填充初始值。<br />另外还有伪操作 `.BLKW`，即 a BLocK of Word，如 `.BLKW 5` 就会占用 5 个 word（16-bit）的空间。<br />还有伪操作 `.STRINGZ` 表示占用 n+1 个 word 用于表示一个 n 个字符的字符串，例如 `.STRINGZ "Hello"` 就会占用 6 个 word，分别保存 5 个字符的 ASCII 码和一个表示结束的 0x0000。请注意，虽然每个 ASCII 码只占 8 位，但是我们仍然用一个 16 位的 word 保存一个字符；因此每个 word 的高 8 位一定是 0。


#### LDR 和 STR - 基址偏移寻址
当我们用 `.BLKW` 或者 `.STRINGZ` 声明一连串内存单元（也许是用来实现数组）时，给它们分别起一个名字是不现实的。因此我们引入了 `LDR` 和 `STR` 操作，它们可以实现：<br />`LDR DR, BaseR, #imm6`，`DR = mem[BaseR + #imm6]`，即根据一个寄存器 BaseR 中的地址和基于这个地址的偏移量找到一个内存单元，将其值置入 DR。这一过程也是改变 CC 的。<br />对应地有 `STR SR, BaseR, #imm6`。


#### LDI 和 STI - 间接寻址
`LDI DR, #imm9` 实现 `DR = mem[mem[PC + #imm9]]`，影响 CC；类似有 `STI SR, #imm9`。<br />每个架构都会设计出不同的寻址方法。事实上，为了看懂汇编语言，我们只需要了解汇编的基本思路，然后看到具体汇编去查找相应的资料或手册了解其含义即可。因此，关于包括该指令在内的若干指令，我们不会再深入讨论其设计意图和用途。面对真正的汇编，我们只需要 **识别** 出其寻址语句，然后查找其含义即可。


### 子程序

#### 子程序
最后一个要探讨的话题就是子程序了。子程序也就是我们 C 语言中所说的函数。要调用函数，我们其实用一条 JMP 语句就能完成；但是我们还要考虑一些问题：

   - 跳转到这个函数没问题，但是函数运行完怎么回来呢？
   - 函数可能不是我写的，我怎么知道他会不会用到我用过的寄存器呢？

这两个问题的答案很简单：保存下当前的 PC 和 R0~R7（或者，只保留那些需要保留的。思考：哪些寄存器是需要保留的？），函数运行结束后跳回 PC 并恢复 R0~R7 即可。

`JSR` Jump to Subroutine 指令的格式是 `JSR #imm11`，其中 `#imm11` 表示相对 PC 的偏移量，也可以是一个标签。这个指令做的事情是 `R7 = PC; PC = PC + #imm11`；即当前 PC 被保存在 R7 寄存器中。<br />`JSRR` 的格式是 `JSRR BaseR`，即 `R7 = PC; PC = BaseR`。<br />对应地，函数结束应该调用 `RET`；它没有操作数，实现的是 `PC = R7`。

寄存器的保存应当由调用者和被调用者的一方来完成。在现代的编程语言中，不同的编译器采取了不同的做法，保存方实际上只需要保存自己会用到的那些寄存器。

如果感兴趣，可以自行在课本中寻找代码，理解相关内容。


#### TRAP
TRAP 是用来调用自带的一些子函数的，这些子函数称为系统调用。有兴趣的话可以自行查阅系统调用的设计原因。<br />例如，I/O 就可以使用 TRAP 来实现；当然还有其他实现方法。这也是计算机系统概论中比较重要的一部分话题，但是与我们的主题关系不大，在此略去。


#### 栈和递归
我们之前在讨论调用函数时保存寄存器的问题时，并没有说明寄存器会保存在哪里。一个自然的想法是在内存某处 `.BLKW 8` 用来存放 8 个寄存器，但如果遇到递归，之前保存的 R7 就会被覆盖，第一次调用这个递归函数的位置就会丢失。为此，我们需要引入栈来解决这个问题。

实际上我们调用函数都会用栈来实现。我们在内存中挑选一块地方当做我们的栈。通常，LC-3 中我们让栈开始于代码的前面，即 x2FFF，这样栈会向低地址方向增长，一直到代码的下方都可以使用 (请理解 0x0000 - 1 = 0xFFFF)。我们会将寄存器信息、函数返回的地址（即当前 PC）、传入参数、返回值（留出一块）都放在栈里。函数中的局部变量也会放到栈里。我们称这些内容为一个函数调用的活动记录。我们在编写代码时，就知道了（或者说，自己设计了）每个参数或者局部变量距离栈顶的偏移量，我们就可以借助一个指向栈顶的指针和这个偏移量来找到每一个数据。

对于 x86 架构汇编，我们会用 sp 指向当前栈顶，一个框架指针 (frame pointer, fp; a.k.a 帧指针, bp) 指向当前活动，这两个指针通常保存在寄存器中。先前活动的 fp 会保存在它调用的函数的活动记录中，形成控制链 (control link; a.k.a 动态链, dynamic link)。需要保存的寄存器，包括传入参数和返回值也可以保存在栈中。

这部分内容是理解实际的函数调用的基础，请务必阅读书上的相关内容，并结合具体例子在 LC-3 模拟器上通过 memory 查看栈的情况，确保理解这部分内容。


#### 中断，PSR，权限模式
这些内容十分重要，但对于我们的 **目标** 来说用处不大。请自行阅读《计算机系统概论》，更深入地学习相关内容。相关的指令是 `RTI`, Return from Interrupt。


### 下一步做什么

#### 看懂真正的汇编
看到这里，也许我们已经具备了一定程度上理解汇编语言了。推荐工具 [https://godbolt.org/](https://godbolt.org/)，可以在线查看各种语言在各种架构、版本的编译器下的编译结果，按行对应，非常方便！

例如：
![image.png](./assets/1639078262052-41d99638-633c-4e48-9b36-95263ab25f04.png)
也许我们主要想了解的是 `int A[100]` 是如何分配空间的，那么我们看到右边这个陌生的汇编代码时会

   - 意识到 `int A[100]` 应该是在绿色部分完成的
   - 查询 `rbp` 和 `rsp` 分别代表什么，得知是帧指针和栈指针
   - 查询 `mov` 是什么意思，得知是赋值
   - 看到 `edi`（不知道是什么）放在了 `[rbp-420]`，即 `rbp` 所指位置 -420 的位置，那么中间空出的 420 字节的空间应该有 400 字节就是给了 A 的。
   - 如果不确定，看黄色部分，`rax` 被赋值为 `[rbp-416]`（这时候应该查一查 `lea` 是什么），随后 `rax` 被 +20，这应该对应的就是源代码 第 4 行的部分，因此 `[rbp-416]` 应该就是 A 的基地址。
   - 如果还不确定，对 `A[0]` 之类的地址做一些赋值试一试？

或许我们更想知道 `B[-1]` 到底是什么，我们看灰色部分：

   - 最后一句是 `mov DWORD PTR [rdx], eax` （这之前应该已经查过 DWORD PTR 是什么了，虽然没必要搞清楚），倒数第二句又是 `eax = [rbp-420]`，结合绿色部分最后一句，可以猜测刚开始 `edi` 大概存的就是传进来的参数 `num`，这里其实做的是 `[rdx] = eax = [rbp-420] = edi = num` 这个过程
   - 那灰色部分前两句就很明显了，我们刚刚分析出 `rdx` 大概就是 B[-1] 的地址，这里也可以证实：`rdx = rax - 4`，而 `rax` 是从栈里取东西，根据前面的分析，就是 B 的值了。

![image.png](./assets/1639078944509-6f25a333-efc7-4727-bfda-f73907a75b5b.png)
换一种架构，又是全新的故事；不过仔细分析，应该也大同小异？


#### 更深入 LC-3
《计算机系统概论》远不仅于此；该著作以及课程仍然在更新，本文基于的第二版实际上也已经过时。这门课程从物理的晶体管，到计算机的逻辑结构，再到汇编，最后到 C 语言，用简单的 LC-3 讲解关于计算机的全部基础。这本书本身也并不厚，中文翻译也尚能接受，因此非常推荐大家阅读这本书！<br />这里有非常不完整的一些笔记：[计算机系统概论 | Introduction to Computing Systems](https://www.yuque.com/xianyuxuan/coding/ez9cdg?view=doc_embed)
课本：

   - 英文第二版

[Introduction to Computing Systems (2nd Edition).pdf](https://www.yuque.com/attachments/yuque/0/2021/pdf/641515/1639080070992-7cb6d9b6-d78f-4b57-9bab-82d3d4faf806.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fpdf%2F641515%2F1639080070992-7cb6d9b6-d78f-4b57-9bab-82d3d4faf806.pdf%22%2C%22name%22%3A%22Introduction%20to%20Computing%20Systems%20(2nd%20Edition).pdf%22%2C%22size%22%3A13739734%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22status%22%3A%22done%22%2C%22taskId%22%3A%22ue6081629-1fbd-4fa4-ab41-50e98f4279b%22%2C%22taskType%22%3A%22upload%22%2C%22id%22%3A%22u30c5db43%22%2C%22card%22%3A%22file%22%7D)

   - 中文第二版

[计算机系统概论第二版.pdf](https://www.yuque.com/attachments/yuque/0/2021/pdf/641515/1639080066605-5913cab5-a71a-4570-a48c-5e62293398a2.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fpdf%2F641515%2F1639080066605-5913cab5-a71a-4570-a48c-5e62293398a2.pdf%22%2C%22name%22%3A%22%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%89%88.pdf%22%2C%22size%22%3A50717398%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22status%22%3A%22done%22%2C%22taskId%22%3A%22u6afd1244-be8c-4df5-a2a0-2944d73373a%22%2C%22taskType%22%3A%22upload%22%2C%22id%22%3A%22u0aeb9cec%22%2C%22card%22%3A%22file%22%7D)

   - 英文第三版

[Introduction to Computing Systems From Bits  Gates to C  Beyond by Yale Patt [Patt, Yale] (z-lib.org).pdf](https://www.yuque.com/attachments/yuque/0/2021/pdf/641515/1639080088271-c9cb04b9-b406-452e-9db9-b9e479248036.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fpdf%2F641515%2F1639080088271-c9cb04b9-b406-452e-9db9-b9e479248036.pdf%22%2C%22name%22%3A%22Introduction%20to%20Computing%20Systems%20From%20Bits%20%20Gates%20to%20C%20%20Beyond%20by%20Yale%20Patt%20%5BPatt%2C%20Yale%5D%20(z-lib.org).pdf%22%2C%22size%22%3A33227336%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22status%22%3A%22done%22%2C%22taskId%22%3A%22uc410d2c2-c1c8-4c26-94ba-1e97eefda82%22%2C%22taskType%22%3A%22upload%22%2C%22id%22%3A%22ud83a418e%22%2C%22card%22%3A%22file%22%7D)
