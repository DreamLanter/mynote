**咸鱼暄insr**

本文试图在不依赖某种具体的编程语言的基础上，梳理面向对象编程 (Object-Oriented Programming, OOP) 的基本理念和概念。我希望通过这种尝试，加深自己对面向对象编程的理解。<br />本文的整理建立在对 C++ 和 Java 的面向对象机制有一定浅显认识的基础上。

本文参考的资料主要包括：

   - 百度百科之类的东西
   - Bruce Eckel, _Thinking in C++, 2nd Edition, Volume 1: Introduction to Standard C++_

_（当然是中文版，英文版我看不懂）_<br />_<br />**对象 (Object)**。单词 Object 的一个意项是“物体、物品”，实际上一切事物都可以理解为一个（研究某项问题）的对象，每个对象都有其 **状态** 和 **行为**。例如，你的男朋友（如果有）就可以理解为一个对象：他的状态包括年龄、身高、职业、资产等等，行为包括学习、赚钱、花钱、长高等等。<br />从编程的角度来看，“状态”可以由数据变量表示，“行为”可以由功能函数（方法）来实现。

**类 (Class)**。刚才我们提到的你的男朋友的状态和行为，在其他的人（我们姑且假设你的男朋友是人类）身上也具备。换句话说，任何一个人都具有上述特性（状态和行为），因此“人类”就是这些人共同所属的类型。再抽象一点来讲，就是每个对象都属于一个描述其特性的类，类是一个共享相同结构和行为的对象的集合。<br />从编程的角度看，类其实是一种数据类型，程序员可以创建这种类型的变量（称为 **对象** 或 **实例 (instance)**）和操纵这些变量（对其发送请求，对象根据信息进行操作）。这种数据类型是状态和行为的集合，通常以变量和函数来描述和定义。这些变量和函数，是这个类的 **成员**。

**接口 (interface) **和** 实现 (implementation)**。刚才我们提到，程序员可以对对象进行操纵。但是，每个类的对象的行为是有限的，比如你不能让作为人类的你的男朋友像空调那样制冷，即每个类的实例只能满足特定的请求，这些请求由这个类描述的特性决定。<br />可以向对象发出的请求是由它的 **接口** 定义的，而接口由类型决定。接口规定我们能够向特定的对象发送什么样的请求，例如人类一般都有“吃饭”这样的接口。我们还需要的就是一个具体的满足这种需求的功能设计。当对象接受与这种接口对应的信息时，就用相应的功能来进行操作。这样的功能设计就是 **实现**。<br />从编程的角度看，接口其实就是函数的声明，而实现则是这些函数的具体定义。与面向过程的编程不同的是，这些函数属于某个具体的类，而不是随处都可以调用。这样的函数，称为这个类的 **成员函数 (member function)** 。

**实现的隐藏**。在编程中，我们可以认为类是一种数据类型。有时，某一个应用程序的开发者可能与其中某个类的创建者不是同一个人，即开发者使用了其他程序员创建的类，这是非常常见的情况。在这种情况下，类的创建者也许不希望使用者可以轻易地了解或者修改接口的具体实现（以便保护版权，或者保证之后改变接口的实现策略时不会对类的使用者产生影响），同时看到这些部分对于类的使用者来说也是不必要的负担（他们只需要知道接口的定义和功能）。因此，限制类使用者的访问权限显得有一定意义。实现的隐藏就是让实现分离并被保护。<br />**<br />**接口的重用——继承 (inheritance)**。我们之前定义了“人类”这个类，有时我们需要更细致的划分。例如我们需要“学生”这样一个类。显然，“学生”是“人类”的真子集，因此“学生”这个类必然拥有“人类”的状态和行为。也就是说，“人类”具有的接口在“学生”中都能找到。而不同的是，“学生”作为一个更细的划分，具有一些“人类”不一定具有的状态和行为，例如均绩和交作业。“人类”是比“学生”更为抽象的一个概念。<br />那么，“学生”作为一个新的类，将“人类”的接口拷贝一份当然是可以达到要求的，但是这将大幅降低设计的效率和模型的可维护性。因此我们引入了 **继承** 这一机制。继承可以让我们克隆一个（或多个）已经存在的类的状态和行为，并在克隆的基础上进行一些增加或修改，从而获得我们需要的类。我们将原来的类称为 **基类**、**超类** 或 **父类**，新的类称为 **派生类**、**继承类** 或 **子类**。<br />我们设计“学生”这个类的时候，可以继承“人类”的接口，然后再额外增加一些接口，例如“交作业”。这样我们就得到了学生这个全新的类。这是继承的典型应用形式之一。<br />继承的另一种应用形式是对基类中的接口设计不同的实现，获得不同的类。这样的操作称为对接口实现的 **重写 (overriding)**。例如，我们希望编写一个绘图程序时设计了“Shape”类，其接口包括 draw 和 move。这个类有“Rectangle”和“Circle”两个子类。这两个子类和基类对 move 的实现是相同的（改变坐标即可），但对 draw 的实现的不同的。此时，Shape, Rectangle 和 Circle 三个类中都包含 draw 这一接口，但也许有 3 个不同的实现。<br />当然，这两种使得子类与父类产生区别的方法是可以共同使用的。

**多态性 (polymorphic)**。继续使用刚才绘图程序的例子。我们给这些类都设计了 draw 这个接口。但是当我们在给一个 Shape 的实例发送信息让它进行 draw 的操作的时候，我们并不希望关注它到底是 Circle 还是 Rectangle，而是希望可以让它自己找到这个接口与实际类型对应的实现（因为一个实例的类型在定义时显然已经是明确的）。<br />调用接口时，基于实例的实际类型选择接口在对应类型中的实现（当实现被重写），这种特性称为 **多态性**。<br />C++ 和 Java 在多态的实现方法中有比较大的不同。

**向上转型 (upcasting)**。有时，我们会将派生类的实例当做基类实例处理，这样的过程称为 **向上类型转换**。这样做的合法性是容易理解的，因为基类是比派生类更抽象的类型，基类中包含的状态和行为在派生类中都是存在的，因此对基类的一切操作在派生类中都是合法的。<br />仍然使用上面绘图程序的例子。例如，我们希望编写一个函数 shapeFun，给定一个图形实例，将其绘制并移动。那么对于这个函数，其传入参数应当是一个 Shape，但是向上转型允许我们传入一个 Circle 或者 Rectangle，因为它们都是 Shape 的子类。此后，我们对这个 Shape 调用 draw 和 move 的接口，多态性会帮助我们找到这个对象的实际类型，并且调用对应的实现。在整个过程中，我们从未对对象的实际类型进行过判断，但是最终执行了正确的操作。当我们在后续的程序设计中为 Shape 加入一个全新的子类（如 “RoundedRectangle”）时，我们不需要对 shapeFun 这个函数作任何改变就可以用于这个全新的子类。这样，程序就具有很不错的可扩展性。<br />在实际编程中，继承的实现使得子类对象的内存分配为 父类内容 + 独有内容。因此，向上转型时程序可以直接在分界处截断，使用前面部分的内容即可获得一个父类的对象。

**组合 (composition)**。希望在一个新的类中使用已经设计好的类的方法不止继承一种。就像我们之前提到的那样，编程中一个类可以包含成员变量和成员函数，而成员变量当然可以是某一个类的实例。这样的设计通常更为灵活，因为我们可以将任意数量和类型的对象放入一个新的类。在很多情况下，组合比继承更为优越。
